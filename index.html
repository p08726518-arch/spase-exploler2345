<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penjelajah Luar Angkasa 3D - Edisi Aksesoris</title>
    <style>
        :root {
            --primary-color: #00aaff;
            --secondary-color: #ffc107;
            --danger-color: #ff4444;
            --success-color: #00ff88;
            --dark-bg: #111;
            --medium-bg: #222;
            --light-bg: #333;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Courier New', Courier, monospace;
        }
        #info, #stats, #accessory-status {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            z-index: 100;
            border: 1px solid var(--light-bg);
        }
        #info { top: 10px; left: 10px; max-width: 300px; }
        #stats { top: 10px; right: 10px; text-align: right; }
        #accessory-status { bottom: 90px; right: 10px; }
        #network-status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ccc; /* Warna default */
            margin-right: 5px;
            vertical-align: middle;
            transition: background-color 0.5s ease;
        }
        #network-status-indicator.good { background-color: var(--success-color); }
        #network-status-indicator.medium { background-color: var(--secondary-color); }
        #network-status-indicator.bad { background-color: var(--danger-color); }
        #accessory-status p { margin: 4px 0; font-size: 0.9em; }
        #minimap-container {
            position: absolute;
            bottom: 90px;
            left: 10px;
            width: 200px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--light-bg);
            border-radius: 10px;
            z-index: 100;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        #ui-bars-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            z-index: 100;
        }
        .bar-container {
            width: 300px;
            height: 30px;
            background-color: rgba(50, 50, 50, 0.8);
            border: 2px solid #888;
            border-radius: 15px;
            padding: 3px;
            position: relative;
        }
        .bar-label {
             position: absolute;
             left: 10px;
             top: 50%;
             transform: translateY(-50%);
             font-size: 0.9em;
             color: white;
             text-shadow: 1px 1px 2px black;
             z-index: 1;
        }
        #fuel-bar, #health-bar, #warmth-bar {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            transition: width 0.2s ease-in-out, background-color 0.5s ease;
        }
        #fuel-bar { background-color: #00ff00; }
        #health-bar { background-color: #28a745; }
        #warmth-bar { background-color: #ff8800; }
        #refuel-message, #booster-message, #speed-boost-message, #freeze-warning {
            position: absolute;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            display: none;
            text-shadow: 2px 2px 4px #000;
            z-index: 250;
            text-align: center;
        }
        #refuel-message { top: 50%; color: var(--secondary-color); }
        #booster-message { top: 40%; color: var(--primary-color); }
        #speed-boost-message { top: 60%; color: #ff00ff; }
        #freeze-warning { top: 30%; color: #87ceeb; font-size: 3em; animation: pulseWarning 1s infinite; }
        @keyframes pulseWarning {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.7; transform: translate(-50%, -50%) scale(1.1); }
        }
        h1, p { margin: 0 0 5px 0; }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 200;
            transition: opacity 0.3s;
        }
        .overlay h2 { font-size: 3em; margin-bottom: 20px; color: var(--secondary-color); }
        .overlay button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: var(--light-bg);
            border: 2px solid #eee;
            color: white;
            border-radius: 10px;
            font-family: 'Courier New', Courier, monospace;
            margin: 8px;
            min-width: 200px;
            transition: all 0.2s ease;
        }
        .overlay button:hover { background-color: #555; border-color: var(--secondary-color); }
        .overlay button:disabled { background-color: #222; color: #777; border-color: #555; cursor: not-allowed;}
        #game-over-screen button { background-color: #bb0000; }
        #game-over-screen button:hover { background-color: #ff0000; }
        /* Dim Screen for Meteor Event */
        #dim-overlay {
            background-color: rgba(0,0,0,0.95);
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }
        /* Hangar & Shop & Crate Styling */
        #hangar-screen, #shop-screen, #crate-screen {
            justify-content: flex-start;
            padding: 30px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            width: 90%;
            max-width: 1400px;
            padding: 20px 0;
        }
        .card {
            background-color: var(--medium-bg);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            transition: all 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .card:hover { transform: translateY(-5px); }
        .card h3 { margin-top: 0; margin-bottom: 8px; color: #eee; font-size: 1em; }
        .card p { font-size: 0.75em; margin-bottom: 8px; min-height: 40px; color: #ccc; }
        .card .cost { font-weight: bold; color: var(--secondary-color); margin-bottom: 8px; }
        .card button { width: 100%; margin-top: 8px; font-size: 0.8em; padding: 8px; }
        .ship-card.unlocked:hover { border-color: var(--success-color); cursor: pointer; }
        .ship-card.locked { background-color: var(--dark-bg); color: #666; }
        .ship-card.affordable { border-color: var(--secondary-color); cursor: pointer; }
        .ship-card.affordable:hover { background-color: #332b00; }
        .ship-card .selected-badge { color: var(--success-color); font-weight: bold; }
        .accessory-card .level { color: var(--primary-color); }
        .accessory-card .upgrade-btn { background-color: var(--primary-color); color: black; }
        .crate-card { border-color: #8A2BE2; }
        .crate-card h3 { color: #DDA0DD; }
        .crate-card button { background-color: #8A2BE2; }
        #crate-result-screen { z-index: 210; }
        #crate-results { margin-top: 20px; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;}
        .result-card { background: var(--light-bg); padding: 15px; border-radius: 8px; border: 1px solid var(--primary-color); width: 180px;}
        .result-card.duplicate { border-color: var(--secondary-color); }
        .result-card p { font-size: 1em; margin: 5px 0; }
        .result-card .points-gain { color: var(--secondary-color); font-weight: bold; }
        .nav-tabs { display: flex; justify-content: center; margin-bottom: 20px; border-bottom: 2px solid var(--light-bg); }
        .nav-tab { background: none; border: none; color: #888; padding: 15px 30px; font-size: 1.5em; cursor: pointer; }
        .nav-tab.active { color: var(--secondary-color); border-bottom: 3px solid var(--secondary-color); }
        /* Kontrol Mobile */
        #mobile-controls { display: none; position: absolute; bottom: 20px; left: 20px; z-index: 300; flex-direction: row; justify-content: space-between; width: calc(100% - 40px); }
        #joystick-area, #fire-button { background-color: rgba(50, 50, 50, 0.7); border: 2px solid #888; border-radius: 50%; }
        #joystick-area { width: 150px; height: 150px; position: relative; }
        #joystick-thumb { width: 60px; height: 60px; background-color: #eee; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #fire-button { width: 100px; height: 100px; background-color: rgba(255, 0, 0, 0.7); border: 2px solid #ff0000; display: flex; justify-content: center; align-items: center; font-size: 1.5em; }
        @media (max-width: 768px) { #mobile-controls { display: flex; } }
        .camera-controls-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 10px;
            z-index: 100;
        }
        .camera-btn {
            background-color: var(--light-bg);
            border: 1px solid #777;
            color: white;
            padding: 5px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Courier New', Courier, monospace;
        }
        .camera-btn:hover {
            background-color: #555;
        }
        .camera-btn.active {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: black;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Misi: <span id="mission-title">Jupiter</span></h1>
        <p>Tugas: Capai target, hancurkan asteroid!</p>
        <p><b>Kontrol:</b> W/S (Maju/Mundur), Panah (Belok), PgUp/PgDn (Atas/Bawah), Spasi (Tembak)</p>
        <p><b>Aksesoris:</b> 1-Shield, 2-Speed, 3-Warmth</p>        
        <p><b>Klik Kiri:</b> Fokus Target Sword Sensor</p>
        <p id="distance-info">Jarak ke Target: ...</p>
    </div>
    <div id="stats">
        <p>Poin: <span id="points">0</span></p>
        <p>Asteroid: <span id="score">0</span></p>
        <p>Jaringan: <span id="network-status-indicator"></span> <span id="ping-value">...</span></p>
    </div>
    <div id="minimap-container">
        <canvas id="minimap-canvas" width="200" height="200"></canvas>
    </div>
    <div id="accessory-status"></div>
    <div id="ui-bars-container">
        <div id="health-container" class="bar-container">
            <div class="bar-label">HEALTH</div>
            <div id="health-bar"></div>
        </div>
         <div id="warmth-container" class="bar-container" style="display: none;">
            <div class="bar-label">KETAHANAN DINGIN</div>
            <div id="warmth-bar"></div>
        </div>
        <div id="fuel-container" class="bar-container">
            <div class="bar-label">FUEL</div>
            <div id="fuel-bar"></div>
        </div>
    </div>
    <p id="refuel-message">MENGISI BAHAN BAKAR</p>
    <p id="booster-message">BOOSTER AKTIF!</p>
    <p id="speed-boost-message">PENINGKATAN KECEPATAN!</p>
    <p id="freeze-warning">SISTEM MEMBEKU!</p>
    <div id="start-screen" class="overlay">
        <!-- Konten menu utama akan dimuat di sini oleh JavaScript -->
    </div>
    <div id="hangar-screen" class="overlay" style="display: none;">
        <div>
            <div class="nav-tabs">
                <button class="nav-tab active" onclick="showTab('hangar-content')">HANGGAR</button>
                <button class="nav-tab" onclick="showTab('shop-content')">AKSESORIS</button>
                <button class="nav-tab" onclick="showTab('crate-content')">CRATE</button>
                <button class="nav-tab" onclick="showTab('settings-content')">PENGATURAN</button>
            </div>
            <div id="hangar-content">
                <h2>HANGGAR PESAWAT</h2>
                <p>Pilih pesawat Anda. Selesaikan misi untuk mendapat poin dan membuka yang baru!</p>
                <div id="ship-grid" class="grid-container"></div>
            </div>
            <div id="shop-content" style="display:none;">
                <h2>TOKO AKSESORIS</h2>
                <p>Beli dan tingkatkan aksesoris untuk membantu petualanganmu!</p>
                <div id="accessory-grid" class="grid-container"></div>
            </div>
             <div id="crate-content" style="display:none;">
                <h2>CRATE PESAWAT</h2>
                <p>Buka crate untuk kesempatan mendapatkan pesawat langka!</p>
                <div id="crate-grid" class="grid-container"></div>
            </div>
            <div id="settings-content" style="display:none;">
                <h2>PENGATURAN</h2>
                <p>Ubah pengaturan grafis. Perubahan akan diterapkan saat game dimulai.</p>
                <div id="settings-grid" class="grid-container" style="grid-template-columns: 1fr;"></div>
            </div>
        </div>
        <button onclick="showMainMenu()" style="position: fixed; bottom: 20px; left: 20px; min-width: 150px;">Kembali ke Menu</button>
    </div>
    <div id="game-over-screen" class="overlay" style="display: none;">
        <h2>GAME OVER</h2><p id="game-over-reason">Anda menabrak asteroid!</p><button onclick="location.reload()">Coba Lagi</button>
    </div>
     <div id="win-screen" class="overlay" style="display: none;">
        <h2>MISI BERHASIL!</h2><p id="win-message">Anda telah sampai di Jupiter dengan selamat!</p><button onclick="location.reload()">Main Lagi</button>
    </div>
    <div id="crate-result-screen" class="overlay" style="display: none;">
        <h2>HASIL CRATE</h2>
        <div id="crate-results"></div>
        <button onclick="document.getElementById('crate-result-screen').style.display = 'none'; showHangar();">Tutup</button>
    </div>
    <div id="dim-overlay" class="overlay" style="display:none;"></div>
    <div id="camera-controls-container" class="camera-controls-container">
        <button id="cam-btn-belakang" class="camera-btn active" onclick="setCameraMode(0)">Belakang</button>
        <button id="cam-btn-depan" class="camera-btn" onclick="setCameraMode(1)">Depan</button>
        <button id="cam-btn-kokpit" class="camera-btn" onclick="setCameraMode(2)">Kokpit</button>
    </div>
    <div id="mobile-controls"><div id="joystick-area"><div id="joystick-thumb"></div></div><div id="fire-button">TEMBAK</div></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Inisialisasi Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.00002); // Kepadatan fog dikurangi agar planet terlihat
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 50000000); // FOV diperkecil dari 75
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const textureLoader = new THREE.TextureLoader();
        // State Game
        let isGameStarted = false, isPaused = false, isGameOver = false, score = 0, currentLevel = 'easy', alienBoss = null, bossLasers = [];
        let minimapCanvas, minimapCtx, minimapScale = 40;
        let shipGroup, starField, denseStarField, shipSpotlight, target; // Target object
        const asteroids = [], lasers = [], aliens = [], alienLasers = [], shipWrecks = [], detectionLines = [], friends = [];
        let focusedTarget = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let cameraMode = 0; // 0: Belakang, 1: Depan, 2: Kokpit
        const cameraModes = ['Belakang', 'Depan', 'Kokpit'];

        // Sistem Health, Bahan Bakar, dll
        let maxHealth = 100, currentHealth = maxHealth;
        let maxFuel = 100, currentFuel = maxFuel;
        // Mekanik Baru: Pembekuan
        let freezeTimer = 49000; // 49 detik
        let timeUntilFreeze = freezeTimer;
        let isFrozen = false;
        let warmthActive = false;
        let warmthDuration = 0;
        let maxWarmth = 60000; // 60 detik
        // Data Player
        let playerData = {};
        const defaultPlayerData = {
            points: 0,
            unlockedShips: [0],
            selectedShipId: 0,
            accessories: {
                shield: { level: 0 },
                speed: { level: 0 },
                sword: { level: 0 },
                flashlight: { level: 0 },
                warmth: { level: 0 },
                fuelTank: { level: 0 },
                healthBooster: { level: 0 },
                pointBooster: { level: 0 },
                friends: { level: 0 },
            },
            settings: {
                realisticMode: false
            }
        };
        // UI Elements
        const pointsInfo = document.getElementById('points');
        const networkIndicator = document.getElementById('network-status-indicator');
        const pingValue = document.getElementById('ping-value');
        // --- DATABASE GAME ---
        const SPACESHIPS = []; // Diisi secara dinamis
        const ACCESSORIES = {
            shield: { id: 'shield', name: 'Shield', baseCost: 70000, maxLevel: 24, desc: (lvl) => `Aktifkan perisai pelindung selama ${14 + lvl} detik. Cooldown: ${60 - lvl} detik.`},
            speed: { id: 'speed', name: 'Speed Boost', baseCost: 28943, maxLevel: 24, desc: (lvl) => `Tingkatkan kecepatan puncak selama ${11 + lvl} detik. Cooldown: ${50 - lvl} detik.`},
            sword: { id: 'sword', name: 'Sword Sensor', baseCost: 5000, maxLevel: 69, desc: (lvl) => `Mendeteksi & merusak hingga 3 objek dalam radius ${200 + lvl * 20} unit. Kerusakan: ${3 + lvl * 5}.`},
            flashlight: { id: 'flashlight', name: 'Senter', baseCost: 1, maxLevel: 24, desc: (lvl) => `Mengurangi efek penglihatan redup dari meteor sebesar ${10 + lvl * 3}%.`},
            warmth: { id: 'warmth', name: 'Pemanas', baseCost: 99124, maxLevel: 24, desc: (lvl) => `Memberi ketahanan dari efek beku selama ${60 + lvl * 5} detik. Cooldown: ${120 - lvl*2} detik.`},
            fuelTank: { id: 'fuelTank', name: 'Tangki Bahan Bakar', baseCost: 15000, maxLevel: 34, desc: (lvl) => `Menambah kapasitas bahan bakar maksimal sebesar ${lvl * 25} unit.`},
            healthBooster: { id: 'healthBooster', name: 'Struktur Diperkuat', baseCost: 25000, maxLevel: 45, desc: (lvl) => `Menambah health maksimal permanen sebesar ${lvl * 4} poin.`},
            pointBooster: { id: 'pointBooster', name: 'Poin Booster', baseCost: 150000, maxLevel: 45, desc: (lvl) => `Meningkatkan perolehan poin dari semua sumber sebesar ${lvl * 40}% secara permanen.`},
            friends: { id: 'friends', name: 'Friends', baseCost: 700000, maxLevel: 2, desc: (lvl) => `Beli drone pendamping. Drone memiliki Sword Sensor 2x lebih kuat dari milikmu. Drone: ${lvl}/2.`}
        };
        const CRATES = [
            { id: 'starter', name: 'Starter Crate', cost: 196000, ships: [1, 2, 3, 4, 5, 6] },
            { id: 'medium', name: 'Medium Crate', cost: 242000, ships: [7, 8, 9, 10, 11, 12, 13, 14] },
            { id: 'legends', name: 'Legends Crate', cost: 397000, ships: [15, 16, 17, 18, 19, 20, 21, 22, 23, 24] },
            { id: 'mysterious', name: 'Mysterious Crate', cost: 474000, ships: [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52] }
        ];
        const DUPLICATE_POINTS = 298;
        const PLANET_TEXTURES = [
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/jupiter.jpg', // Jupiter
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/saturn.jpg', // Saturn
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/uranus.jpg', // Uranus
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/neptune.jpg', // Neptune
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/pluto_1k_color.jpg', // Fictional rocky
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/mars_1k_color.jpg', // Fictional red
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/venus_surface.jpg', // Fictional hot
            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg', // Fictional moon-like
        ];
        // --- PENGATURAN KESULITAN ---
        const DIFFICULTY_SETTINGS = {
            easy:       { asteroidCount: 1000, baseDistance: 60000, pointMultiplier: 1.0, meteorInterval: 15000, freezeResist: 1.2, largeMeteorChance: 0.1, alienInvasionInterval: 90000, frozenMeteorInterval: 90000, bossInvasionInterval: 360000 },
            medium:     { asteroidCount: 2000, baseDistance: 80000, pointMultiplier: 1.5, meteorInterval: 12000, freezeResist: 1.0, largeMeteorChance: 0.2, alienInvasionInterval: 80000, frozenMeteorInterval: 80000, bossInvasionInterval: 320000 },
            hard:       { asteroidCount: 4000, baseDistance: 100000, pointMultiplier: 2.0, meteorInterval: 10000, freezeResist: 0.9, largeMeteorChance: 0.3, alienInvasionInterval: 70000, frozenMeteorInterval: 70000, bossInvasionInterval: 280000 },
            hardcore:   { asteroidCount: 6000, baseDistance: 120000, pointMultiplier: 2.5, meteorInterval: 8000, freezeResist: 0.8, largeMeteorChance: 0.4, alienInvasionInterval: 60000, frozenMeteorInterval: 60000, bossInvasionInterval: 240000 },
            impossible: { asteroidCount: 8000, baseDistance: 180000, pointMultiplier: 200, meteorInterval: 7000, freezeResist: 0.7, largeMeteorChance: 0.5, alienInvasionInterval: 55000, frozenMeteorInterval: 55000, bossInvasionInterval: 220000 },
            'legends-senior': { asteroidCount: 10000, baseDistance: 220000, pointMultiplier: 439, meteorInterval: 6000, freezeResist: 0.6, largeMeteorChance: 0.6, alienInvasionInterval: 50000, frozenMeteorInterval: 50000, bossInvasionInterval: 200000 },
            'mystery-adventurer': { asteroidCount: 12000, baseDistance: 280000, pointMultiplier: 648, meteorInterval: 5000, freezeResist: 0.5, largeMeteorChance: 0.7, alienInvasionInterval: 45000, frozenMeteorInterval: 45000, bossInvasionInterval: 180000 },
            'so-long': { asteroidCount: 15000, baseDistance: 500000, pointMultiplier: 800, meteorInterval: 4500, freezeResist: 0.4, largeMeteorChance: 0.8, alienInvasionInterval: 40000, frozenMeteorInterval: 40000, bossInvasionInterval: 160000 },
            'speed-of-spase': { asteroidCount: 12000, baseDistance: 350000, pointMultiplier: 1200, meteorInterval: 4000, freezeResist: 0.3, largeMeteorChance: 0.9, alienInvasionInterval: 35000, frozenMeteorInterval: 35000, bossInvasionInterval: 140000 },
            'are-you-sure': { asteroidCount: 20000, baseDistance: 800000, pointMultiplier: 2500, meteorInterval: 3000, freezeResist: 0.2, largeMeteorChance: 1.0, alienInvasionInterval: 30000, frozenMeteorInterval: 30000, bossInvasionInterval: 120000 },
            'hero-of-spase': { asteroidCount: 25000, baseDistance: 1000000, pointMultiplier: 4000, meteorInterval: 2500, freezeResist: 0.1, largeMeteorChance: 1.0, alienInvasionInterval: 25000, frozenMeteorInterval: 25000, bossInvasionInterval: 100000 }
        };
        let currentMissionIndex = 0;
        let maxSpeed, acceleration, turnSpeed, laserFireSpeed, currentProjectileStats, refuelRate;
        let speed = 0.0, angularVelocity = 0.0, verticalSpeed = 0.0;
        const shipInertia = 0.95, shipDrift = 0.995, verticalDrift = 0.95;
        // Status Aksesoris
        const accessoryCooldowns = { shield: 0, speed: 0, warmth: 0 };
        let shieldActive = false, speedBoostActive = false;
        // --- DAFTAR MISI ---
        const MISSIONS = [
            { name: 'Jupiter', distance: 60000, desc: 'Raksasa gas terbesar di tata surya.' },
            { name: 'Saturnus', distance: 120000, desc: 'Planet dengan cincin megah.' },
            { name: 'Uranus', distance: 250000, desc: 'Planet es yang berputar miring.' },
            { name: 'Neptunus', distance: 400000, desc: 'Planet biru paling jauh dari matahari.' },
            { name: 'HD 114762 b', distance: 800000, desc: 'Planet ekstrasurya pertama yang ditemukan.' },
            { name: 'GJ 367 b', distance: 950000, desc: 'Planet super panas yang padat.' },
            { name: 'WASP-107b', distance: 1100000, desc: 'Planet "kapas" dengan atmosfer tebal.' },
            { name: 'K2-3d', distance: 1300000, desc: 'Planet seukuran Bumi di zona layak huni.' },
            { name: 'LHS 1140 b', distance: 1500000, desc: 'Planet batuan di zona layak huni.' },
            { name: 'Gliese 667 Cc', distance: 1700000, desc: 'Planet potensial layak huni.' },
            { name: 'Kepler-16b', distance: 1900000, desc: 'Tatooine versi nyata, mengorbit dua bintang.' },
            { name: 'GJ 1214 b', distance: 2100000, desc: 'Planet air dengan atmosfer tebal.' },
            { name: 'Kepler-438b', distance: 2300000, desc: 'Planet mirip Bumi yang mungkin layak huni.' },
            { name: 'Ross 128 b', distance: 2500000, desc: 'Planet tenang di zona layak huni.' },
            { name: 'KELT-9b', distance: 2700000, desc: 'Planet terpanas yang pernah ditemukan.' },
            { name: 'Galaksi Andromeda', distance: 5000000, desc: 'Galaksi spiral terdekat, akan bertabrakan dengan Bima Sakti.' },
            { name: 'Galaksi Triangulum', distance: 7000000, desc: 'Galaksi spiral kecil, tetangga Andromeda.' },
            { name: 'Galaksi Sombrero', distance: 9000000, desc: 'Galaksi dengan tonjolan pusat besar dan piringan debu.' },
            { name: 'Galaksi Whirlpool', distance: 11000000, desc: 'Galaksi spiral klasik yang berinteraksi.' },
            { name: 'Galaksi Tadpole', distance: 13000000, desc: 'Galaksi dengan ekor panjang akibat tabrakan.' },
            { name: 'Galaksi Black Eye', distance: 15000000, desc: 'Galaksi dengan pita debu gelap yang mencolok.' },
            { name: 'Galaksi Messier 87', distance: 17000000, desc: 'Galaksi elips raksasa dengan lubang hitam supermasif.' }
        ];
        // --- FUNGSI UTAMA ---
        function loadPlayerData() {
            const savedData = localStorage.getItem('spaceExplorerData');
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                playerData = { ...defaultPlayerData, ...parsedData };
                playerData.accessories = { ...defaultPlayerData.accessories, ...parsedData.accessories };
                playerData.settings = { ...defaultPlayerData.settings, ...parsedData.settings };
            } else {
                playerData = JSON.parse(JSON.stringify(defaultPlayerData));
            }
            pointsInfo.innerText = playerData.points.toLocaleString();
        }
        function savePlayerData() {
            localStorage.setItem('spaceExplorerData', JSON.stringify(playerData));
            pointsInfo.innerText = playerData.points.toLocaleString();
        }
        function init() {
            generateShipDatabase();
            loadPlayerData();
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            createScenery();
            setupJoystick();
            showMainMenu();
            minimapCanvas = document.getElementById('minimap-canvas');
            minimapCtx = minimapCanvas.getContext('2d');
            window.addEventListener('mousedown', onMouseDown, false);
            checkPing(); // Cek ping saat pertama kali load
            setInterval(checkPing, 5000); // Cek ping setiap 5 detik
        }
        function populateDifficultyButtons() {
            const grid = document.getElementById('difficulty-grid');
            grid.innerHTML = '';
            for (const key in DIFFICULTY_SETTINGS) {
                const button = document.createElement('button');
                button.textContent = `${key.replace(/-/g, ' ').toUpperCase()} (${DIFFICULTY_SETTINGS[key].pointMultiplier}x Poin)`;
                button.onclick = () => selectDifficulty(key);
                grid.appendChild(button);
            }
        }
        function showMainMenu() {
            const startScreen = document.getElementById('start-screen');
            startScreen.style.display = 'flex';
            startScreen.innerHTML = `
                <h2>PENJELAJAH LUAR ANGKASA</h2>
                <button onclick="showDifficultyMenu()">PLAY</button>
                <button onclick="showHangar()">MORE</button>
            `;
            document.getElementById('hangar-screen').style.display = 'none';
        }
        function showDifficultyMenu() {
            const startScreen = document.getElementById('start-screen');
            startScreen.innerHTML = `
                <h2>PILIH LEVEL KESULITAN</h2>
                <div id="difficulty-grid"></div>
                <button onclick="showMainMenu()">KEMBALI</button>
            `;
            populateDifficultyButtons();
        }
        function selectDifficulty(difficulty) {
            currentLevel = difficulty;
            document.getElementById('start-screen').style.display = 'none';
            startGame();
        }
        function startGame() {
            isGameStarted = true;
            // Hapus teman dari game sebelumnya
            friends.forEach(f => scene.remove(f.shipGroup));
            friends.length = 0;

            document.getElementById('hangar-screen').style.display = 'none';
            const shipData = SPACESHIPS.find(s => s.id === playerData.selectedShipId) || SPACESHIPS[0];
            setupShipStats(shipData);
            createPlayer(shipData);
            const settings = DIFFICULTY_SETTINGS[currentLevel];
            timeUntilFreeze = freezeTimer * settings.freezeResist;
            currentMissionIndex = 0;
            const firstMission = MISSIONS[currentMissionIndex];
            document.getElementById('mission-title').innerText = firstMission.name;
            let targetMaterial;
            const isRealistic = playerData.settings && playerData.settings.realisticMode;
            if (isRealistic) {
                const textureUrl = PLANET_TEXTURES[currentMissionIndex % PLANET_TEXTURES.length];
                const texture = textureLoader.load(textureUrl);
                targetMaterial = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9 });
            } else {
                targetMaterial = new THREE.MeshPhongMaterial({ color: 0xE8A763 });
            }
            target = { object: new THREE.Mesh(new THREE.SphereGeometry(400, 64, 64), targetMaterial) };
            target.object.position.z = -firstMission.distance;
            scene.add(target.object);
            createAsteroids(settings.asteroidCount, 0.5, -firstMission.distance, 0);
            setInterval(() => { if(isGameStarted && !isGameOver && Math.random() < settings.largeMeteorChance) startLargeMeteorEvent(); }, settings.meteorInterval);
            setInterval(() => { if(isGameStarted && !isGameOver) triggerAlienInvasion(); }, settings.alienInvasionInterval);
            setInterval(() => { if(isGameStarted && !isGameOver && !alienBoss) triggerBossInvasion(); }, settings.bossInvasionInterval);
            setInterval(() => { if(isGameStarted && !isGameOver) triggerFrozenMeteorEvent(); }, settings.frozenMeteorInterval);
            
            // Buat teman berdasarkan level
            for (let i = 0; i < playerData.accessories.friends.level; i++) {
                createFriend(i);
            }
            animate();
        }
        // --- UI & NAVIGASI MENU ---
        function showHangar() {
            document.getElementById('start-screen').style.display = 'none';
            const hangarScreen = document.getElementById('hangar-screen');
            hangarScreen.style.display = 'flex';
            populateShipGrid();
            populateAccessoryGrid();
            populateCrateGrid();
            populateSettingsGrid();
            showTab('hangar-content');
        }
        function showTab(tabId) {
            ['hangar-content', 'shop-content', 'crate-content', 'settings-content'].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            document.getElementById(tabId).style.display = 'block';
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.nav-tab[onclick="showTab('${tabId}')"]`).classList.add('active');
        }
        function populateShipGrid() {
            const shipGrid = document.getElementById('ship-grid');
            shipGrid.innerHTML = '';
            SPACESHIPS.forEach(ship => {
                const card = document.createElement('div');
                card.className = 'card ship-card';
                const isUnlocked = playerData.unlockedShips.includes(ship.id);
                const canAfford = playerData.points >= ship.cost;
                if (isUnlocked) {
                    card.classList.add('unlocked');
                    card.onclick = () => selectShip(ship.id); 
                } else {
                    card.classList.add('locked');
                    if (canAfford) {
                        card.classList.add('affordable');
                        card.onclick = () => buyShip(ship.id);
                    }
                }
                card.innerHTML = `
                    <h3>${ship.name}</h3>
                    <p>${ship.desc}</p>
                    ${isUnlocked ? `<p class="selected-badge">${playerData.selectedShipId === ship.id ? '&#10004; DIPILIH' : 'KLIK UNTUK PILIH'}</p>` : `<p class="cost">Poin: ${ship.cost.toLocaleString()}</p>`}
                `;
                if (playerData.selectedShipId === ship.id) card.style.borderColor = 'var(--success-color)';
                shipGrid.appendChild(card);
            });
        }
        function selectShip(shipId) {
             playerData.selectedShipId = shipId;
             savePlayerData();
             populateShipGrid();
        }
        function buyShip(shipId) {
            const ship = SPACESHIPS.find(s => s.id === shipId);
            if (ship && playerData.points >= ship.cost && !playerData.unlockedShips.includes(shipId)) {
                playerData.points -= ship.cost;
                playerData.unlockedShips.push(ship.id);
                savePlayerData();
                populateShipGrid(); 
            }
        }
        function populateAccessoryGrid() {
            const grid = document.getElementById('accessory-grid');
            grid.innerHTML = '';
            for (const key in ACCESSORIES) {
                const acc = ACCESSORIES[key];
                const data = playerData.accessories[key];
                const isMaxLevel = data.level >= acc.maxLevel;
                let cost = 0;
                
                if (key === 'fuelTank') {
                    if (data.level < 6) {
                        cost = 0;
                    } else {
                        cost = Math.floor(acc.baseCost * Math.pow(1.5, data.level - 6));
                    }
                } else if (key === 'flashlight') {
                    const level = data.level;
                    if (level === 0) cost = 1;
                    else if (level === 1) cost = 2;
                    else if (level === 2) cost = 3;
                    else cost = 5000000 * Math.pow(2, level - 3);
                } else if (key === 'friends') {
                    cost = acc.baseCost;
                } else {
                    cost = Math.floor(acc.baseCost * Math.pow(1.8, data.level));
                }

                const canAfford = playerData.points >= cost;
                const card = document.createElement('div');
                card.className = 'card accessory-card';
                card.innerHTML = `
                    <h3>${acc.name}</h3>
                    <p>${acc.desc(data.level)}</p>
                    <p class="level">Level: ${data.level} / ${acc.maxLevel}</p>
                    <p class="cost">${isMaxLevel ? 'MAX' : (cost === 0 ? 'GRATIS!' : `Upgrade: ${cost.toLocaleString()} Poin`)}</p>
                    <button class="upgrade-btn" onclick="upgradeAccessory('${key}')" ${isMaxLevel || !canAfford ? 'disabled' : ''}>
                        ${isMaxLevel ? 'LEVEL MAX' : 'UPGRADE'}
                    </button>
                `;
                grid.appendChild(card);
            }
        }
        function upgradeAccessory(key) {
            const acc = ACCESSORIES[key];
            const data = playerData.accessories[key];
            if (data.level >= acc.maxLevel) return;
            let cost = 0;

            if (key === 'fuelTank') {
                if (data.level < 6) {
                    cost = 0;
                } else {
                    cost = Math.floor(acc.baseCost * Math.pow(1.5, data.level - 6));
                }
            } else if (key === 'flashlight') {
                const level = data.level;
                if (level === 0) cost = 1; else if (level === 1) cost = 2; else if (level === 2) cost = 3;
                else cost = 5000000 * Math.pow(2, level - 3);
            } else if (key === 'friends') {
                cost = acc.baseCost;
            } else {
                cost = Math.floor(acc.baseCost * Math.pow(1.8, data.level));
            }
            if (playerData.points >= cost) {
                playerData.points -= cost;
                data.level++;
                savePlayerData();
                populateAccessoryGrid();
            }
        }
        function populateCrateGrid() {
             const grid = document.getElementById('crate-grid');
             grid.innerHTML = '';
             CRATES.forEach(crate => {
                const canAfford = playerData.points >= crate.cost;
                const card = document.createElement('div');
                card.className = 'card crate-card';
                card.innerHTML = `
                    <h3>${crate.name}</h3>
                    <p class="cost">Biaya: ${crate.cost.toLocaleString()} Poin</p>
                    <button onclick="openCrate('${crate.id}')" ${!canAfford ? 'disabled' : ''}>BUKA</button>
                `;
                grid.appendChild(card);
             });
        }
        function openCrate(crateId) {
            const crate = CRATES.find(c => c.id === crateId);
            if (!crate || playerData.points < crate.cost) return;
            playerData.points -= crate.cost;
            const resultsContainer = document.getElementById('crate-results');
            resultsContainer.innerHTML = '';
            for (let i = 0; i < 4; i++) {
                const randomShipId = crate.ships[Math.floor(Math.random() * crate.ships.length)];
                const ship = SPACESHIPS.find(s => s.id === randomShipId);
                let isDuplicate = playerData.unlockedShips.includes(randomShipId);
                if (isDuplicate) {
                    playerData.points += DUPLICATE_POINTS;
                } else {
                    playerData.unlockedShips.push(randomShipId);
                }
                const card = document.createElement('div');
                card.className = `result-card ${isDuplicate ? 'duplicate' : ''}`;
                card.innerHTML = `<p>${ship.name}</p>${isDuplicate ? `<p class="points-gain">+${DUPLICATE_POINTS} Poin (Duplikat)</p>` : '<p>BARU!</p>'}`;
                resultsContainer.appendChild(card);
            }
            savePlayerData();
            populateCrateGrid();
            document.getElementById('crate-result-screen').style.display = 'flex';
        }
        function populateSettingsGrid() {
            const grid = document.getElementById('settings-grid');
            grid.innerHTML = '';

            const realisticMode = playerData.settings.realisticMode;

            const card = document.createElement('div');
            card.className = 'card';
            card.style.textAlign = 'left';
            card.innerHTML = `
                <h3>Mode Realistis</h3>
                <p>Mengaktifkan tekstur dan model yang lebih detail untuk asteroid dan objek lain. Mungkin mempengaruhi performa.</p>
                <p>Status: <b style="color: ${realisticMode ? 'var(--success-color)' : 'var(--danger-color)'}">${realisticMode ? 'AKTIF' : 'NONAKTIF'}</b></p>
                <button onclick="toggleRealisticMode()">
                    ${realisticMode ? 'Nonaktifkan' : 'Aktifkan'}
                </button>
            `;
            grid.appendChild(card);
        }
        function toggleRealisticMode() {
            playerData.settings.realisticMode = !playerData.settings.realisticMode;
            savePlayerData();
            populateSettingsGrid();
        }
        // --- PEMBUATAN OBJEK & STATS ---
        function setupShipStats(shipData) {
             const healthBonus = playerData.accessories.healthBooster.level * 4;
             maxHealth = shipData.stats.health + healthBonus;
             currentHealth = maxHealth;
             maxSpeed = shipData.stats.maxSpeed;
             const fuelBonus = playerData.accessories.fuelTank.level * 25;
             maxFuel = shipData.stats.fuel + fuelBonus;
             acceleration = shipData.stats.accel;
             turnSpeed = shipData.stats.turn;
             laserFireSpeed = shipData.stats.laserSpeed;
             refuelRate = shipData.stats.refuelRate;
             currentProjectileStats = shipData.stats.projectile;
             currentFuel = maxFuel;
        }
        function createPlayer(shipData) {
            shipGroup = new THREE.Group();
            const id = shipData.id;

            // --- AURA UNIK UNTUK SETIAP PESAWAT ---
            // Membuat PointLight yang warnanya ditentukan oleh ID pesawat untuk menciptakan efek aura.
            const auraColor = new THREE.Color().setHSL( (id * 137.5) % 360 / 360, 0.9, 0.6 ); // Menggunakan Golden Angle untuk sebaran warna yang baik
            const auraLight = new THREE.PointLight(auraColor, 2.5, 50, 2); // (warna, intensitas, jarak, peluruhan)
            auraLight.position.set(0, 0.5, 0); // Posisikan di tengah pesawat, sedikit di atas
            shipGroup.add(auraLight);

            // --- MATERIAL UMUM (dapat digunakan kembali) ---
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xadb5bd, // Abu-abu metalik netral
                metalness: 0.9,
                roughness: 0.4,
            });
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x6c757d, // Abu-abu lebih gelap untuk kontras
                metalness: 0.8,
                roughness: 0.6,
            });
            const cockpitMaterial = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                emissive: 0x0077cc, // Efek menyala
                emissiveIntensity: 0.5,
                metalness: 0.2,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7,
            });
            const engineGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff8c00, // Cahaya oranye terang
                toneMapped: false, // Memastikan cahaya tidak terpengaruh oleh pencahayaan scene
            });

            // --- GENERASI PROSEDURAL BERDASARKAN ID ---
            const modelType = Math.floor(id / 6);
            
            switch (modelType) {
                case 0: { // ID 0-5: Scout
                    const bodyLength = 3.5 + (id % 6) * 0.15;
                    const wingSpan = 3.0 + (id % 6) * 0.2;
                    const mainBody = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, bodyLength, 6), bodyMaterial);
                    mainBody.rotation.x = Math.PI / 2;
                    shipGroup.add(mainBody);
                    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.0), cockpitMaterial);
                    cockpit.position.set(0, 0.4, bodyLength / 2 - 0.8);
                    shipGroup.add(cockpit);
                    const wings = new THREE.Mesh(new THREE.BoxGeometry(wingSpan, 0.15, 1.2), wingMaterial);
                    wings.position.z = -0.5;
                    shipGroup.add(wings);
                    const engine = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 1.5, 8), bodyMaterial);
                    engine.rotation.x = Math.PI / 2;
                    engine.position.set(0, 0, -bodyLength / 2);
                    shipGroup.add(engine);
                    const glow = new THREE.Mesh(new THREE.CircleGeometry(0.35, 16), engineGlowMaterial);
                    glow.position.set(0, 0, (-bodyLength / 2) - 0.76);
                    shipGroup.add(glow);
                    break;
                }
                case 1: { // ID 6-11: Interceptor
                    const bodyLength = 4.0 + (id % 6) * 0.2;
                    const wingSpan = 3.5 + (id % 6) * 0.3;
                    const mainBodyGeo = new THREE.CylinderGeometry(0.4, 0.7, bodyLength, 8);
                    const mainBody = new THREE.Mesh(mainBodyGeo, bodyMaterial);
                    mainBody.rotation.x = Math.PI / 2;
                    shipGroup.add(mainBody);
                    const noseConeGeo = new THREE.ConeGeometry(0.4, 1.5, 8);
                    const noseCone = new THREE.Mesh(noseConeGeo, bodyMaterial);
                    noseCone.position.z = (bodyLength / 2) + 0.75;
                    noseCone.rotation.x = Math.PI / 2;
                    shipGroup.add(noseCone);
                    const cockpitGeo = new THREE.SphereGeometry(0.6, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                    const cockpit = new THREE.Mesh(cockpitGeo, cockpitMaterial);
                    cockpit.position.set(0, 0.5, (bodyLength / 2) - 1.0);
                    shipGroup.add(cockpit);
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0, 0); wingShape.lineTo(0, -1.8); wingShape.lineTo(wingSpan, -1.0); wingShape.lineTo(wingSpan, 0.4); wingShape.lineTo(0, 0);
                    const extrudeSettings = { depth: 0.15, bevelEnabled: false };
                    const wingGeo = new THREE.ExtrudeGeometry(wingShape, extrudeSettings);
                    wingGeo.rotateX(-Math.PI / 2);
                    const rightWing = new THREE.Mesh(wingGeo, wingMaterial);
                    rightWing.position.set(0.5, 0, 0);
                    shipGroup.add(rightWing);
                    const leftWing = new THREE.Mesh(wingGeo.clone(), wingMaterial);
                    leftWing.scale.x = -1;
                    leftWing.position.set(-0.5, 0, 0);
                    shipGroup.add(leftWing);
                    const engineGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.8, 8);
                    const rightEngine = new THREE.Mesh(engineGeo, bodyMaterial);
                    rightEngine.rotation.x = Math.PI / 2;
                    rightEngine.position.set(1.2, -0.1, -bodyLength / 2 + 0.5);
                    shipGroup.add(rightEngine);
                    const leftEngine = new THREE.Mesh(engineGeo, bodyMaterial);
                    leftEngine.rotation.x = Math.PI / 2;
                    leftEngine.position.set(-1.2, -0.1, -bodyLength / 2 + 0.5);
                    shipGroup.add(leftEngine);
                    const glowGeo = new THREE.CircleGeometry(0.25, 16);
                    const rightGlow = new THREE.Mesh(glowGeo, engineGlowMaterial);
                    rightGlow.position.set(1.2, -0.1, (-bodyLength / 2) - 0.41);
                    shipGroup.add(rightGlow);
                    const leftGlow = new THREE.Mesh(glowGeo, engineGlowMaterial);
                    leftGlow.position.set(-1.2, -0.1, (-bodyLength / 2) - 0.41);
                    shipGroup.add(leftGlow);
                    break;
                }
                case 2: { // ID 12-17: Gunship
                    const bodyLength = 5.0 + (id % 6) * 0.2;
                    const wingSpan = 4.0 + (id % 6) * 0.3;
                    const mainBodyGeo = new THREE.CylinderGeometry(0.9, 0.7, bodyLength, 8);
                    const mainBody = new THREE.Mesh(mainBodyGeo, bodyMaterial);
                    mainBody.rotation.x = Math.PI / 2;
                    shipGroup.add(mainBody);
                    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.7, 2.0), cockpitMaterial);
                    cockpit.position.set(0, 0.8, (bodyLength / 2) - 1.5);
                    shipGroup.add(cockpit);
                    const wingGeo = new THREE.BoxGeometry(wingSpan, 0.25, 1.8);
                    const wings = new THREE.Mesh(wingGeo, wingMaterial);
                    wings.position.z = -1.0;
                    shipGroup.add(wings);
                    const weaponPodGeo = new THREE.BoxGeometry(1.0, 0.8, 3.0);
                    const rightPod = new THREE.Mesh(weaponPodGeo, bodyMaterial);
                    rightPod.position.set(1.8, 0, 0.5);
                    shipGroup.add(rightPod);
                    const leftPod = new THREE.Mesh(weaponPodGeo, bodyMaterial);
                    leftPod.position.set(-1.8, 0, 0.5);
                    shipGroup.add(leftPod);
                    const engineGeo = new THREE.CylinderGeometry(0.4, 0.5, 2.0, 6);
                    const enginePositions = [ new THREE.Vector3(1.2, 0.4, -bodyLength / 2), new THREE.Vector3(-1.2, 0.4, -bodyLength / 2), new THREE.Vector3(1.2, -0.4, -bodyLength / 2), new THREE.Vector3(-1.2, -0.4, -bodyLength / 2), ];
                    enginePositions.forEach(pos => {
                        const engine = new THREE.Mesh(engineGeo, bodyMaterial);
                        engine.rotation.x = Math.PI / 2;
                        engine.position.copy(pos);
                        shipGroup.add(engine);
                        const glow = new THREE.Mesh(new THREE.CircleGeometry(0.35, 16), engineGlowMaterial);
                        glow.position.set(pos.x, pos.y, pos.z - 1.01);
                        shipGroup.add(glow);
                    });
                    break;
                }
                case 3: { // ID 18-23: Heavy Cargo
                    const bodyWidth = 2.5 + (id % 6) * 0.1;
                    const bodyHeight = 1.2 + (id % 6) * 0.1;
                    const bodyLength = 6.0 + (id % 6) * 0.2;
                    const mainBody = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyLength), bodyMaterial);
                    shipGroup.add(mainBody);
                    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.7, 1.8), cockpitMaterial);
                    cockpit.position.set(0, bodyHeight / 2, bodyLength / 2 - 0.6);
                    shipGroup.add(cockpit);
                    const wingGeo = new THREE.BoxGeometry(3.5, 0.2, 2.5);
                    const rightWing = new THREE.Mesh(wingGeo, wingMaterial);
                    rightWing.position.set(bodyWidth / 2 + 1.75, 0, 0);
                    rightWing.rotation.z = -0.1;
                    shipGroup.add(rightWing);
                    const leftWing = new THREE.Mesh(wingGeo, wingMaterial);
                    leftWing.position.set(-(bodyWidth / 2 + 1.75), 0, 0);
                    leftWing.rotation.z = 0.1;
                    shipGroup.add(leftWing);
                    const engineGeo = new THREE.CylinderGeometry(0.8, 0.9, 3.5, 8);
                    const enginePositions = [new THREE.Vector3(bodyWidth / 2 + 1.2, -0.5, -0.5), new THREE.Vector3(-(bodyWidth / 2 + 1.2), -0.5, -0.5)];
                    enginePositions.forEach(pos => {
                        const engine = new THREE.Mesh(engineGeo, bodyMaterial);
                        engine.rotation.x = Math.PI / 2;
                        engine.position.copy(pos);
                        shipGroup.add(engine);
                        const glow = new THREE.Mesh(new THREE.CircleGeometry(0.7, 16), engineGlowMaterial);
                        glow.position.set(pos.x, pos.y, pos.z - 1.76);
                        shipGroup.add(glow);
                    });
                    break;
                }
                case 4: { // ID 24-29: High-Tech
                    const mainColor = new THREE.Color(0xeeeeff);
                    const accentColor = new THREE.Color(0x00aaff);
                    const highTechBodyMat = new THREE.MeshStandardMaterial({ color: mainColor, metalness: 0.9, roughness: 0.3 });
                    const highTechAccentMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.8, roughness: 0.4 });
                    const bodyLength = 6 + (id % 6) * 0.2;
                    const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, bodyLength), highTechBodyMat);
                    shipGroup.add(body);
                    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 2.0), cockpitMaterial);
                    cockpit.position.set(0, 0.2, bodyLength / 2 - 1.2);
                    shipGroup.add(cockpit);
                    const wingSpan = 4 + (id % 6) * 0.3;
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0, 0); wingShape.lineTo(wingSpan, -1.5); wingShape.lineTo(wingSpan, -0.5); wingShape.lineTo(0, -2.0); wingShape.lineTo(0, 0);
                    const wingExtrudeSettings = { depth: 0.15, bevelEnabled: false };
                    const wingGeo = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
                    wingGeo.rotateX(-Math.PI / 2);
                    const rightWing = new THREE.Mesh(wingGeo, highTechAccentMat);
                    rightWing.position.set(0.75, 0, 0);
                    shipGroup.add(rightWing);
                    const leftWing = new THREE.Mesh(wingGeo.clone(), highTechAccentMat);
                    leftWing.scale.x = -1;
                    leftWing.position.set(-0.75, 0, 0);
                    shipGroup.add(leftWing);
                    const canardGeo = new THREE.BoxGeometry(1.5, 0.1, 0.8);
                    const rightCanard = new THREE.Mesh(canardGeo, highTechAccentMat);
                    rightCanard.position.set(1.5, 0.2, bodyLength / 2 - 2.5);
                    shipGroup.add(rightCanard);
                    const leftCanard = new THREE.Mesh(canardGeo, highTechAccentMat);
                    leftCanard.position.set(-1.5, 0.2, bodyLength / 2 - 2.5);
                    shipGroup.add(leftCanard);
                    break;
                }
                case 5: { // ID 30-35: Asymmetrical/Scavenger
                    const scrapMat1 = new THREE.MeshStandardMaterial({ color: 0x8B4513, metalness: 0.6, roughness: 0.8 });
                    const scrapMat2 = new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.9, roughness: 0.5 });
                    const body1 = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 4), scrapMat1);
                    body1.position.z = 2;
                    shipGroup.add(body1);
                    const body2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.2, 4, 8), scrapMat2);
                    body2.rotation.x = Math.PI / 2;
                    shipGroup.add(body2);
                    const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 6), cockpitMaterial);
                    cockpit.position.set(-1.5, 0.5, 2);
                    shipGroup.add(cockpit);
                    const rightWing = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 2), scrapMat1);
                    rightWing.position.set(3, 0, 0);
                    rightWing.rotation.z = -0.1;
                    shipGroup.add(rightWing);
                    const engine1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), scrapMat2);
                    engine1.position.set(0.8, 0, -3);
                    shipGroup.add(engine1);
                    const glow1 = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), engineGlowMaterial);
                    glow1.position.set(0.8, 0, -4.01);
                    shipGroup.add(glow1);
                    break;
                }
                case 6: { // ID 36-41: Marauder/Reaver (Desain Baru)
                    const reaverBodyMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.4 });
                    const reaverAccentMat = new THREE.MeshStandardMaterial({ color: 0x8B0000, metalness: 0.7, roughness: 0.6 }); // Merah Gelap
                    const reaverGlowMat = new THREE.MeshBasicMaterial({ color: 0xff4500, toneMapped: false }); // Cahaya Oranye-Merah

                    const bodyLength = 7 + (id % 6) * 0.2;
                    const mainBody = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, bodyLength), reaverBodyMat);
                    shipGroup.add(mainBody);

                    // Kokpit tajam
                    const cockpit = new THREE.Mesh(new THREE.ConeGeometry(0.6, 2.5, 4), cockpitMaterial);
                    cockpit.rotation.x = Math.PI / 2;
                    cockpit.position.set(0, 0.3, bodyLength / 2 - 0.5);
                    shipGroup.add(cockpit);

                    // Sayap agresif menyapu ke belakang
                    const wingSpan = 5 + (id % 6) * 0.3;
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0, 0); wingShape.lineTo(wingSpan, 1.5); wingShape.lineTo(wingSpan - 1, 0); wingShape.lineTo(0, -2.5); wingShape.lineTo(0, 0);
                    const wingExtrudeSettings = { depth: 0.15, bevelEnabled: false };
                    const wingGeo = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
                    wingGeo.rotateX(-Math.PI / 2);

                    const rightWing = new THREE.Mesh(wingGeo, reaverAccentMat);
                    rightWing.position.set(0.75, 0, -1);
                    shipGroup.add(rightWing);

                    const leftWing = new THREE.Mesh(wingGeo.clone(), reaverAccentMat);
                    leftWing.scale.x = -1;
                    leftWing.position.set(-0.75, 0, -1);
                    shipGroup.add(leftWing);

                    // Mesin kotak ganda
                    const engineGeo = new THREE.BoxGeometry(0.8, 0.8, 2.5);
                    const enginePositions = [new THREE.Vector3(1.2, 0, -bodyLength / 2), new THREE.Vector3(-1.2, 0, -bodyLength / 2)];
                    enginePositions.forEach(pos => {
                        const engine = new THREE.Mesh(engineGeo, reaverBodyMat);
                        engine.position.copy(pos);
                        shipGroup.add(engine);
                        const glow = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.7), reaverGlowMat);
                        glow.position.set(pos.x, pos.y, pos.z - 1.26);
                        shipGroup.add(glow);
                    });
                    break;
                }
                case 7: { // ID 42-47: Stealth
                    const stealthMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.8, roughness: 0.9, flatShading: true });
                    const mainBody = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 7), stealthMat);
                    shipGroup.add(mainBody);
                    const nose = new THREE.Mesh(new THREE.ConeGeometry(0.75, 2, 4), stealthMat);
                    nose.rotation.x = Math.PI / 2;
                    nose.position.z = 4.5;
                    shipGroup.add(nose);
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0, 0); wingShape.lineTo(4, -2.5); wingShape.lineTo(0, -3.5); wingShape.lineTo(0, 0);
                    const wingGeo = new THREE.ExtrudeGeometry(wingShape, { depth: 0.1, bevelEnabled: false });
                    wingGeo.rotateX(-Math.PI / 2);
                    const rightWing = new THREE.Mesh(wingGeo, stealthMat);
                    rightWing.position.set(0.75, 0, 1);
                    shipGroup.add(rightWing);
                    const leftWing = new THREE.Mesh(wingGeo.clone(), stealthMat);
                    leftWing.scale.x = -1;
                    leftWing.position.set(-0.75, 0, 1);
                    shipGroup.add(leftWing);
                    const stealthGlowMat = new THREE.MeshBasicMaterial({ color: 0x0055ff, toneMapped: false });
                    const engineGlow = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.1), stealthGlowMat);
                    engineGlow.position.set(0, 0, -3.55);
                    shipGroup.add(engineGlow);
                    break;
                }
                case 8: { // ID 48-53: Advanced High-Tech (Genesis, Hyperion, Icarus, Juggernaut, Karma)
                    const mainColor = new THREE.Color(0xffffff); // Warna putih bersih
                    const accentColor = new THREE.Color(0x00ffff); // Aksen cyan
                    const advBodyMat = new THREE.MeshStandardMaterial({ color: mainColor, metalness: 0.95, roughness: 0.2 });
                    const advAccentMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.8, roughness: 0.4, emissive: accentColor, emissiveIntensity: 0.5 });

                    const bodyLength = 7 + (id % 6) * 0.3;
                    const bodyWidth = 1.8;

                    // Badan utama yang ramping
                    const mainBody = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth, 0.8, bodyLength), advBodyMat);
                    shipGroup.add(mainBody);

                    // Kokpit terintegrasi
                    const cockpitGeo = new THREE.ConeGeometry(bodyWidth / 2, 2, 4);
                    const cockpit = new THREE.Mesh(cockpitGeo, cockpitMaterial);
                    cockpit.rotation.x = Math.PI / 2;
                    cockpit.position.set(0, 0.2, bodyLength / 2);
                    shipGroup.add(cockpit);

                    // Sayap menyapu ke depan (Forward-swept wings)
                    const wingSpan = 6 + (id % 6) * 0.4;
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0, 0); wingShape.lineTo(-wingSpan, 1.5); wingShape.lineTo(-wingSpan, 0.5); wingShape.lineTo(0, -1.5); wingShape.lineTo(0, 0);
                    const wingExtrudeSettings = { depth: 0.1, bevelEnabled: false };
                    const wingGeo = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
                    wingGeo.rotateX(-Math.PI / 2);

                    const rightWing = new THREE.Mesh(wingGeo, advAccentMat);
                    rightWing.position.set(bodyWidth / 2, 0, 1);
                    shipGroup.add(rightWing);

                    const leftWing = new THREE.Mesh(wingGeo.clone(), advAccentMat);
                    leftWing.scale.x = -1;
                    leftWing.position.set(-bodyWidth / 2, 0, 1);
                    shipGroup.add(leftWing);

                    // Mesin dengan glow terintegrasi
                    const engineGlow = new THREE.Mesh(new THREE.BoxGeometry(bodyWidth * 0.8, 0.2, 0.2), engineGlowMaterial);
                    engineGlow.material.color.set(accentColor); // Sesuaikan warna glow dengan aksen
                    engineGlow.position.set(0, 0, -bodyLength / 2 - 0.1);
                    shipGroup.add(engineGlow);

                    break;
                }
                default: { // ID 54+: Exotic
                    const mainColor = new THREE.Color().setHSL((id % 18) / 18, 0.7, 0.5);
                    const accentColor = new THREE.Color().setHSL(((id + 5) % 18) / 18, 0.7, 0.6);
                    const exoticBodyMat = new THREE.MeshStandardMaterial({ color: mainColor, metalness: 0.5, roughness: 0.8 });
                    const exoticWingMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.9, roughness: 0.4 });
                    const exoticGlowMat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(((id + 10) % 18) / 18, 1.0, 0.7), toneMapped: false });
                    const body = new THREE.Mesh(new THREE.ConeGeometry(1.5, 6, 6), exoticBodyMat);
                    body.rotation.z = Math.PI / 2;
                    shipGroup.add(body);
                    const wingShape1 = new THREE.Shape();
                    wingShape1.moveTo(0,0); wingShape1.lineTo(5, 2); wingShape1.lineTo(4, -1); wingShape1.lineTo(0,-0.5);
                    const rightWing = new THREE.Mesh(new THREE.ExtrudeGeometry(wingShape1, { depth: 0.2, bevelEnabled: false }), exoticWingMat);
                    rightWing.position.set(0, 0.5, 0);
                    rightWing.rotation.x = -0.2;
                    shipGroup.add(rightWing);
                    const wingShape2 = new THREE.Shape();
                    wingShape2.moveTo(0,0); wingShape2.lineTo(-4, 1); wingShape2.lineTo(-3, -2); wingShape2.lineTo(0,-0.5);
                    const leftWing = new THREE.Mesh(new THREE.ExtrudeGeometry(wingShape2, { depth: 0.2, bevelEnabled: false }), exoticWingMat);
                    leftWing.position.set(0, -0.5, 0.5);
                    leftWing.rotation.x = 0.2;
                    shipGroup.add(leftWing);
                    const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), cockpitMaterial);
                    cockpit.position.set(0, 0, 1);
                    shipGroup.add(cockpit);
                    const enginePositions = [ new THREE.Vector3(2, 0, -2), new THREE.Vector3(-1.5, 1, -2.5), new THREE.Vector3(-1.5, -1, -2.5) ];
                    enginePositions.forEach(pos => {
                        const engine = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), exoticBodyMat);
                        engine.position.copy(pos);
                        shipGroup.add(engine);
                        const glow = new THREE.Mesh(new THREE.CircleGeometry(0.3, 16), exoticGlowMat);
                        glow.position.set(pos.x, pos.y, pos.z - 0.01);
                        glow.lookAt(shipGroup.position);
                        shipGroup.add(glow);
                    });
                    break;
                }
            }

            // Penyesuaian akhir untuk semua model
            shipGroup.scale.set(1.2, 1.2, 1.2);

            scene.add(shipGroup);
            const flashlightLevel = playerData.accessories.flashlight.level;
            if (flashlightLevel > 0) {
                shipSpotlight = new THREE.SpotLight(0xffffff, 2, 1000, Math.PI / (10 - flashlightLevel * 0.2), 0.5, 2);
                shipGroup.add(shipSpotlight);
                shipGroup.add(shipSpotlight.target);
            }
            camera.position.set(0, 3, 10);
        }
        function createFriend(index) {
            const friendGroup = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.3 });
            const accentMat = new THREE.MeshStandardMaterial({ color: 0x00aaff, metalness: 0.8, roughness: 0.5 });
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, toneMapped: false });

            const body = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 6), bodyMat);
            friendGroup.add(body);

            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0); wingShape.lineTo(3, 0.5); wingShape.lineTo(3, -0.5); wingShape.lineTo(0, 0);
            const wingGeo = new THREE.ExtrudeGeometry(wingShape, { depth: 0.1, bevelEnabled: false });

            const rightWing = new THREE.Mesh(wingGeo, accentMat);
            rightWing.position.set(1, 0, 0);
            friendGroup.add(rightWing);

            const leftWing = new THREE.Mesh(wingGeo.clone(), accentMat);
            leftWing.scale.x = -1;
            leftWing.position.set(-1, 0, 0);
            friendGroup.add(leftWing);
            
            const glow = new THREE.Mesh(new THREE.CircleGeometry(0.5, 16), glowMat);
            glow.position.z = -1.51;
            friendGroup.add(glow);

            friendGroup.scale.set(0.8, 0.8, 0.8);
            
            // Tentukan posisi offset berdasarkan index (0: kiri, 1: kanan)
            const offset = new THREE.Vector3((index === 0 ? -15 : 15), 0, -5);

            const friendObject = {
                shipGroup: friendGroup,
                offset: offset,
                detectionLines: []
            };
            friends.push(friendObject);
            scene.add(friendGroup);
        }
        function createScenery() {
            const starVertices1 = [];
            for (let i = 0; i < 300000; i++) {
                const x = (Math.random() - 0.5) * 5000000, y = (Math.random() - 0.5) * 5000000, z = (Math.random() - 0.5) * 5000000;
                starVertices1.push(x, y, z);
            }
            const starsGeometry1 = new THREE.BufferGeometry();
            starsGeometry1.setAttribute('position', new THREE.Float32BufferAttribute(starVertices1, 3));
            starField = new THREE.Points(starsGeometry1, new THREE.PointsMaterial({ color: 0xffffff, size: 3.5 }));
            scene.add(starField);
        }
        function createAsteroids(count, speedMultiplier, minZ, maxZ) {
            const distance = Math.abs(maxZ - minZ);
            const rangeX = distance * 0.05, rangeY = distance * 0.05;

            const difficultyLevels = Object.keys(DIFFICULTY_SETTINGS);
            const difficultyIndex = difficultyLevels.indexOf(currentLevel);
            const healthMultiplier = Math.pow(3, difficultyIndex);

            let asteroidGeometry, asteroidMaterial;
            const isRealistic = playerData.settings && playerData.settings.realisticMode;

            if (isRealistic) {
                // Mode Realistis: Geometri tidak beraturan dan material standar
                asteroidGeometry = new THREE.IcosahedronGeometry(1, 3); // Lebih detail
                const positionAttribute = asteroidGeometry.getAttribute('position');
                const tempVertex = new THREE.Vector3();
                for (let i = 0; i < positionAttribute.count; i++) {
                    tempVertex.fromBufferAttribute(positionAttribute, i);
                    const noise = 0.3 * (Math.random() - 0.5);
                    tempVertex.multiplyScalar(1 + noise);
                    positionAttribute.setXYZ(i, tempVertex.x, tempVertex.y, tempVertex.z);
                }
                asteroidGeometry.computeVertexNormals();
                // Material dasar untuk di-clone, lebih efisien daripada membuat material baru di setiap loop
                const asteroidTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/moon_1024.jpg');
                const asteroidNormalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/moon_1k_normal.jpg');
                asteroidMaterial = new THREE.MeshStandardMaterial({ 
                    map: asteroidTexture, 
                    normalMap: asteroidNormalMap, // Menambahkan detail permukaan dengan normal map
                    roughness: 0.9, 
                    metalness: 0.1 
                });
            } else {
                // Mode Default: Geometri simpel dan flat shading
                asteroidGeometry = new THREE.IcosahedronGeometry(1, 0); 
                asteroidMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, flatShading: true });
            }

            for (let i = 0; i < count; i++) {
                const material = asteroidMaterial.clone();
                if (isRealistic) {
                    material.color.setHSL(0, 0, Math.random() * 0.4 + 0.2); // Variasi warna abu-abu (0.2 - 0.6)
                }
                const asteroid = new THREE.Mesh(asteroidGeometry, material);
                const zPos = minZ + (Math.random() * distance);
                asteroid.position.set((Math.random() - 0.5) * rangeX, (Math.random() - 0.5) * rangeY, zPos);
                const scale = Math.random() * 40 + 15;
                asteroid.scale.set(scale, scale, scale);
                asteroid.velocity = new THREE.Vector3((Math.random() - 0.5) * speedMultiplier, (Math.random() - 0.5) * speedMultiplier, (Math.random() - 0.5) * speedMultiplier);
                asteroid.health = 15 * healthMultiplier;
                asteroid.isTargetable = true;
                asteroid.rotationSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01
                );
                asteroids.push(asteroid);
                scene.add(asteroid);
            }
        }
        // --- KONTROL & GERAKAN ---
        const keyboard = {};
        window.addEventListener('keydown', (e) => { keyboard[e.key.toLowerCase()] = true; handleAccessoryKeyPress(e.key); });
        window.addEventListener('keyup', (e) => { keyboard[e.key.toLowerCase()] = false; });
        
        function setCameraMode(newMode) {
            if (!isGameStarted || isGameOver || cameraMode === newMode) return;
            cameraMode = newMode;

            // Update button active state
            document.querySelectorAll('.camera-btn').forEach(btn => btn.classList.remove('active'));
            if (newMode === 0) document.getElementById('cam-btn-belakang').classList.add('active');
            else if (newMode === 1) document.getElementById('cam-btn-depan').classList.add('active');
            else if (newMode === 2) document.getElementById('cam-btn-kokpit').classList.add('active');

            // Hapus kamera dari parent sebelumnya untuk menghindari duplikasi
            if (camera.parent) {
                camera.parent.remove(camera);
            }

            if (newMode === 2) { // Mode Kokpit
                shipGroup.add(camera);
                // Atur posisi & rotasi lokal kamera relatif terhadap pesawat
                camera.position.set(0, 0.5, 1.5); 
                camera.rotation.set(0, Math.PI, 0); // Kamera melihat ke depan dari dalam pesawat (rotasi 180 derajat di sumbu Y)
            } else { // Mode Belakang atau Depan
                scene.add(camera); // Tambahkan kamera kembali ke scene utama
            }
        }

        window.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); fireProjectile(); }});
        
        function onMouseDown(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const objectsToIntersect = asteroids.filter(a => a.isTargetable);
            const intersects = raycaster.intersectObjects(objectsToIntersect);
            if (intersects.length > 0) {
                focusedTarget = intersects[0].object;
            } else {
                focusedTarget = null;
            }
        }

        function updateShipMovement(deltaTime) {
            if (isPaused || !deltaTime) return;
            if (isFrozen) {
                speed *= shipDrift;
                angularVelocity *= shipInertia;
                verticalSpeed *= verticalDrift;
                shipGroup.rotation.y += angularVelocity;
                shipGroup.translateZ(speed);
                shipGroup.position.y += verticalSpeed;
                return;
            }
            const currentSpeedMultiplier = speedBoostActive ? 2 : 1;
            const currentMaxSpeed = maxSpeed * currentSpeedMultiplier;
            const fuelConsumptionRate = 5;
            const verticalAccel = 0.1;
            const maxVerticalSpeed = 5;

            if ((keyboard['w']) && currentFuel > 0) {
                 speed = Math.min(speed + acceleration, currentMaxSpeed);
                 currentFuel -= fuelConsumptionRate * (deltaTime / 1000);
            } else {
                if (currentFuel < maxFuel) {
                    currentFuel = Math.min(currentFuel + refuelRate * (deltaTime / 1000), maxFuel);
                }
            }
            
            if (keyboard['s']) { speed = Math.max(speed - acceleration, -maxSpeed / 2); }
            if (keyboard['arrowleft']) { angularVelocity = Math.min(angularVelocity + 0.002, turnSpeed); }
            if (keyboard['arrowright']) { angularVelocity = Math.max(angularVelocity - 0.002, -turnSpeed); }
            if (keyboard['pageup']) { verticalSpeed = Math.min(verticalSpeed + verticalAccel, maxVerticalSpeed); }
            if (keyboard['pagedown']) { verticalSpeed = Math.max(verticalSpeed - verticalAccel, -maxVerticalSpeed); }

            speed *= shipDrift;
            angularVelocity *= shipInertia;
            verticalSpeed *= verticalDrift;
            shipGroup.rotation.y += angularVelocity;
            shipGroup.translateZ(speed);
            shipGroup.position.y += verticalSpeed;
            if (shipSpotlight) {
                shipSpotlight.target.position.set(0, 0, -1);
            }
        }
        // --- MEKANIK GAME BARU ---
        function updateFreezeStatus(deltaTime) {
            timeUntilFreeze -= deltaTime;
            if (timeUntilFreeze <= 0 && !isFrozen && !warmthActive) {
                isFrozen = true;
                document.getElementById('freeze-warning').innerText = "SISTEM BEKU!";
                document.getElementById('freeze-warning').style.display = 'block';
                setTimeout(() => {
                    isFrozen = false;
                    timeUntilFreeze = freezeTimer * DIFFICULTY_SETTINGS[currentLevel].freezeResist;
                    document.getElementById('freeze-warning').style.display = 'none';
                }, 5000);
            }
            if (warmthActive) {
                warmthDuration -= deltaTime;
                 if (warmthDuration <= 0) {
                    warmthActive = false;
                    warmthDuration = 0;
                    document.getElementById('warmth-container').style.display = 'none';
                }
            }
            document.getElementById('warmth-bar').style.width = `${(warmthDuration / maxWarmth) * 100}%`;
        }
        function startLargeMeteorEvent() {
            const flashlightLevel = playerData.accessories.flashlight.level;
            const maxOpacity = 0.95;
            const reduction = (10 + flashlightLevel * 3) / 100;
            const finalOpacity = maxOpacity * (1 - reduction);
            const dimOverlay = document.getElementById('dim-overlay');
            dimOverlay.style.opacity = finalOpacity;
            dimOverlay.style.display = 'block';
            setTimeout(() => { dimOverlay.style.opacity = 0; }, 8000);
            setTimeout(() => { dimOverlay.style.display = 'none'; }, 10000);
        }

        function damageAsteroid(asteroid, damage) {
            if (!asteroid || asteroid.health === undefined) return;
            asteroid.health -= damage;

            if (asteroid.health <= 0) {
                const index = asteroids.indexOf(asteroid);
                if (index === -1) return; 

                if (asteroid.isFrozenMeteor && !asteroid.isFragment) {
                    createFrozenFragments(asteroid.position, asteroid.velocity);
                    const pointMultiplier = 1 + (playerData.accessories.pointBooster.level * 0.4);
                    playerData.points += Math.round(100 * DIFFICULTY_SETTINGS[currentLevel].pointMultiplier * pointMultiplier);
                    savePlayerData();
                } else { 
                    score++;
                    document.getElementById('score').innerText = score;
                }

                if (asteroid === focusedTarget) {
                    focusedTarget = null;
                }

                scene.remove(asteroid);
                asteroids.splice(index, 1);
            }
        }

       function updateSwordSensor() {
            detectionLines.forEach(line => scene.remove(line));
            detectionLines.length = 0;
        
            const swordLevel = playerData.accessories.sword.level;
            if (swordLevel === 0 || !shipGroup) return;
        
            const detectionRadius = 200 + swordLevel * 20;
            const swordDamage = 3 + swordLevel * 5;
            const now = Date.now();
            const swordCooldown = 1000;
            const material = new THREE.LineBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
            
            let allTargets = [];

            // --- Kumpulkan semua target potensial ---
            if (focusedTarget && focusedTarget.health > 0 && shipGroup.position.distanceTo(focusedTarget.position) < detectionRadius) {
                if (!allTargets.includes(focusedTarget)) allTargets.push(focusedTarget);
            } else if(focusedTarget) {
                focusedTarget = null; 
            }

            asteroids.forEach(asteroid => {
                if (asteroid.isTargetable && shipGroup.position.distanceTo(asteroid.position) < detectionRadius) {
                    if (!allTargets.includes(asteroid)) allTargets.push(asteroid);
                }
            });

            aliens.forEach(alien => {
                if (shipGroup.position.distanceTo(alien.position) < detectionRadius) {
                    if (!allTargets.includes(alien)) allTargets.push(alien);
                }
            });

            if (alienBoss && shipGroup.position.distanceTo(alienBoss.position) < detectionRadius) {
                if (!allTargets.includes(alienBoss)) allTargets.push(alienBoss);
            }

            // Urutkan target berdasarkan jarak terdekat
            allTargets.sort((a, b) => shipGroup.position.distanceTo(a.position) - shipGroup.position.distanceTo(b.position));

            // Ambil hanya 3 target terdekat
            const finalTargets = allTargets.slice(0, 3);

            // --- Beri kerusakan pada target yang dipilih ---
            finalTargets.forEach(target => {
                const points = [shipGroup.position.clone(), target.position.clone()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                detectionLines.push(line);
                scene.add(line);

                if (!target.lastSwordHitTime || now > target.lastSwordHitTime + swordCooldown) {
                    target.lastSwordHitTime = now;

                    if (asteroids.includes(target)) {
                        damageAsteroid(target, swordDamage);
                    } else if (aliens.includes(target)) {
                        target.health -= swordDamage;
                        if (target.health <= 0) {
                            const pointMultiplier = 1 + (playerData.accessories.pointBooster.level * 0.4);
                            playerData.points += Math.round(50 * pointMultiplier); savePlayerData();
                            scene.remove(target);
                            const index = aliens.indexOf(target);
                            if (index > -1) aliens.splice(index, 1);
                        }
                    } else if (target === alienBoss) {
                        target.health -= swordDamage;
                        if (target.health <= 0) {
                            const pointMultiplier = 1 + (playerData.accessories.pointBooster.level * 0.4);
                            playerData.points += Math.round(5000 * pointMultiplier);
                            savePlayerData();
                            scene.remove(target);
                            alienBoss = null;
                        }
                    }
                }
            });
        }
        function updateFriends() {
            if (!shipGroup || friends.length === 0) return;

            friends.forEach(friend => {
                // Update Posisi & Rotasi
                const targetPosition = friend.offset.clone().applyMatrix4(shipGroup.matrixWorld);
                friend.shipGroup.position.lerp(targetPosition, 0.08);
                friend.shipGroup.quaternion.slerp(shipGroup.quaternion, 0.08);

                // Update Logika Sword Sensor untuk teman
                friend.detectionLines.forEach(line => scene.remove(line));
                friend.detectionLines.length = 0;

                const swordLevel = playerData.accessories.sword.level;
                if (swordLevel === 0) return; // Sensor teman bergantung pada sensor pemain

                const detectionRadius = 200 + swordLevel * 20;
                const swordDamage = (3 + swordLevel * 5) * 2; // Kerusakan 2x lebih kuat
                const now = Date.now();
                const swordCooldown = 1000;
                const material = new THREE.LineBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.5 }); // Garis biru untuk teman

                let allTargets = [];
                
                // Teman memindai target dari posisinya sendiri
                asteroids.forEach(asteroid => {
                    if (asteroid.isTargetable && friend.shipGroup.position.distanceTo(asteroid.position) < detectionRadius) {
                        if (!allTargets.includes(asteroid)) allTargets.push(asteroid);
                    }
                });
                aliens.forEach(alien => {
                    if (friend.shipGroup.position.distanceTo(alien.position) < detectionRadius) {
                        if (!allTargets.includes(alien)) allTargets.push(alien);
                    }
                });
                if (alienBoss && friend.shipGroup.position.distanceTo(alienBoss.position) < detectionRadius) {
                    if (!allTargets.includes(alienBoss)) allTargets.push(alienBoss);
                }

                allTargets.sort((a, b) => friend.shipGroup.position.distanceTo(a.position) - friend.shipGroup.position.distanceTo(b.position));
                const finalTargets = allTargets.slice(0, 3); // Batas target sama seperti pemain

                finalTargets.forEach(target => {
                    const points = [friend.shipGroup.position.clone(), target.position.clone()];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, material);
                    friend.detectionLines.push(line);
                    scene.add(line);

                    if (!target.lastFriendHitTime || now > target.lastFriendHitTime + swordCooldown) {
                        target.lastFriendHitTime = now; // Timestamp terpisah untuk teman

                        if (asteroids.includes(target)) {
                            damageAsteroid(target, swordDamage);
                        } else if (aliens.includes(target)) {
                            target.health -= swordDamage;
                            if (target.health <= 0) {
                                const pointMultiplier = 1 + (playerData.accessories.pointBooster.level * 0.4);
                                playerData.points += Math.round(50 * pointMultiplier); savePlayerData();
                                scene.remove(target);
                                const index = aliens.indexOf(target);
                                if (index > -1) aliens.splice(index, 1);
                            }
                        } else if (target === alienBoss) {
                            target.health -= swordDamage;
                        }
                    }
                });
            });
        }
        // --- FUNGSI ALIEN & METEOR BEKU ---
        function createAlienShip(position) {
            const alienGroup = new THREE.Group();
            const isRealistic = playerData.settings && playerData.settings.realisticMode;
            const saucerMaterial = isRealistic
                ? new THREE.MeshStandardMaterial({ color: 0x9400D3, metalness: 0.5, roughness: 0.6 })
                : new THREE.MeshPhongMaterial({ color: 0x9400D3, flatShading: true });
            const saucerBodyGeo = new THREE.CylinderGeometry(10, 10, 2, 16);
            const saucerBody = new THREE.Mesh(saucerBodyGeo, saucerMaterial);
            alienGroup.add(saucerBody);
            const domeGeo = new THREE.SphereGeometry(5, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const dome = new THREE.Mesh(domeGeo, saucerMaterial);
            dome.position.y = 1;
            alienGroup.add(dome);
            alienGroup.position.copy(position);
            alienGroup.health = 23;
            alienGroup.lastFireTime = 0;
            aliens.push(alienGroup);
            scene.add(alienGroup);
        }

        function triggerAlienInvasion() {
            if (!shipGroup) return;
            const spawnDistance = 2000;
            const angle = Math.random() * Math.PI * 2;
            const startX = shipGroup.position.x + Math.cos(angle) * spawnDistance;
            const startZ = shipGroup.position.z + Math.sin(angle) * spawnDistance;
            
            for(let i = 0; i < 6; i++) {
                const offsetX = (Math.random() - 0.5) * 500;
                const offsetY = (Math.random() - 0.5) * 200;
                const offsetZ = (Math.random() - 0.5) * 500;
                const spawnPos = new THREE.Vector3(startX + offsetX, shipGroup.position.y + offsetY, startZ + offsetZ);
                createAlienShip(spawnPos);
            }
        }

        function triggerFrozenMeteorEvent() {
            if (!shipGroup) return;
            const spawnDistance = 2500;
            const angle = Math.random() * Math.PI * 2;
            const spawnPos = new THREE.Vector3(
                shipGroup.position.x + Math.cos(angle) * spawnDistance,
                shipGroup.position.y + (Math.random() - 0.5) * 500,
                shipGroup.position.z + Math.sin(angle) * spawnDistance
            );
            createFrozenMeteor(spawnPos);
        }

        function createFrozenMeteor(position) {
            const difficultyLevels = Object.keys(DIFFICULTY_SETTINGS);
            const difficultyIndex = difficultyLevels.indexOf(currentLevel);
            const healthMultiplier = Math.pow(3, difficultyIndex);

            const meteorMaterial = new THREE.MeshPhongMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.9, flatShading: true });
            const meteorGeometry = new THREE.OctahedronGeometry(60, 1);
            const meteor = new THREE.Mesh(meteorGeometry, meteorMaterial);
            meteor.position.copy(position);
            
            meteor.health = 49 * healthMultiplier;
            meteor.isTargetable = true;
            meteor.isFrozenMeteor = true;
            meteor.isFragment = false;
            
            const directionToPlayer = new THREE.Vector3().subVectors(shipGroup.position, meteor.position).normalize();
            meteor.velocity = directionToPlayer.multiplyScalar(Math.random() * 2 + 1);

            asteroids.push(meteor);
            scene.add(meteor);
        }

        function createFrozenFragments(position, initialVelocity) {
            const difficultyLevels = Object.keys(DIFFICULTY_SETTINGS);
            const difficultyIndex = difficultyLevels.indexOf(currentLevel);
            const healthMultiplier = Math.pow(3, difficultyIndex);

            const fragmentMaterial = new THREE.MeshPhongMaterial({ color: 0xADD8E6, transparent: true, opacity: 0.8, flatShading: true });
            const fragmentGeometry = new THREE.TetrahedronGeometry(25, 0);

            for (let i = 0; i < 5; i++) {
                const fragment = new THREE.Mesh(fragmentGeometry, fragmentMaterial);
                fragment.position.copy(position);

                const spread = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3
                );
                fragment.velocity = initialVelocity.clone().add(spread);

                fragment.health = 30 * healthMultiplier;
                fragment.isTargetable = true;
                fragment.isFrozenMeteor = true; 
                fragment.isFragment = true;

                asteroids.push(fragment);
                scene.add(fragment);
            }
        }

        function createAlienBoss(position) {
            if (alienBoss) return; // Hanya satu bos pada satu waktu

            const isRealistic = playerData.settings && playerData.settings.realisticMode;
            const bossGroup = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.5, flatShading: !isRealistic });
            const cannonMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.4, flatShading: !isRealistic });
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, toneMapped: false });

            // Badan utama
            const bodyGeo = new THREE.CylinderGeometry(15, 20, 50, 8);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            bossGroup.add(body);

            // Meriam
            const cannonGeo = new THREE.CylinderGeometry(4, 4, 30, 8);
            const leftCannon = new THREE.Mesh(cannonGeo, cannonMat);
            leftCannon.rotation.x = Math.PI / 2;
            leftCannon.position.set(-25, 0, 0);
            bossGroup.add(leftCannon);

            const rightCannon = new THREE.Mesh(cannonGeo, cannonMat);
            rightCannon.rotation.x = Math.PI / 2;
            rightCannon.position.set(25, 0, 0);
            bossGroup.add(rightCannon);

            // Cahaya Meriam
            const glowGeo = new THREE.CircleGeometry(3.5, 16);
            const leftGlow = new THREE.Mesh(glowGeo, glowMat);
            leftGlow.position.set(-25, 0, 15.1);
            bossGroup.add(leftGlow);

            const rightGlow = new THREE.Mesh(glowGeo, glowMat);
            rightGlow.position.set(25, 0, 15.1);
            bossGroup.add(rightGlow);

            bossGroup.position.copy(position);
            bossGroup.health = 1000; // Health tinggi
            bossGroup.lastFireTime = 0;
            
            alienBoss = bossGroup;
            scene.add(alienBoss);
        }

        function triggerBossInvasion() {
            if (!shipGroup || alienBoss) return;
            const spawnDistance = 4000;
            const angle = Math.random() * Math.PI * 2;
            const spawnPos = new THREE.Vector3(
                shipGroup.position.x + Math.cos(angle) * spawnDistance,
                shipGroup.position.y,
                shipGroup.position.z + Math.sin(angle) * spawnDistance
            );
            createAlienBoss(spawnPos);
        }

        function updateAlienBoss(deltaTime) {
            if (!alienBoss || !shipGroup) return;

            const bossSpeed = 5;
            const fireCooldown = 3000; // Tembak setiap 3 detik

            const direction = new THREE.Vector3().subVectors(shipGroup.position, alienBoss.position).normalize();
            alienBoss.position.add(direction.multiplyScalar(bossSpeed * (deltaTime / 1000)));
            alienBoss.lookAt(shipGroup.position);

            const now = Date.now();
            if (now > alienBoss.lastFireTime + fireCooldown) {
                alienBoss.lastFireTime = now;
                const laserMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Laser hijau
                const laserGeo = new THREE.CylinderGeometry(1, 1, 15, 8);
                
                // Tembak dari kedua meriam
                [-25, 25].forEach(offsetX => {
                    const laser = new THREE.Mesh(laserGeo, laserMat);
                    const spawnPoint = new THREE.Vector3(offsetX, 0, 15);
                    spawnPoint.applyMatrix4(alienBoss.matrixWorld);
                    laser.position.copy(spawnPoint);
                    
                    const laserVelocity = new THREE.Vector3().subVectors(shipGroup.position, laser.position).normalize().multiplyScalar(60);
                    laser.velocity = laserVelocity;
                    laser.quaternion.copy(alienBoss.quaternion);
                    laser.rotateX(Math.PI / 2);

                    bossLasers.push(laser);
                    scene.add(laser);
                });
            }
        }

        function updateBossLasers() {
            for (let i = bossLasers.length - 1; i >= 0; i--) {
                const laser = bossLasers[i];
                laser.position.add(laser.velocity);
                if (shipGroup && laser.position.distanceTo(shipGroup.position) > 5000) {
                    scene.remove(laser);
                    bossLasers.splice(i, 1);
                }
            }
        }


        function updateAliens(deltaTime) {
            if (!shipGroup) return;
            const alienSpeed = 10;
            const fireCooldown = 2000;

            for (let i = aliens.length - 1; i >= 0; i--) {
                const alien = aliens[i];
                const direction = new THREE.Vector3().subVectors(shipGroup.position, alien.position).normalize();
                alien.position.add(direction.multiplyScalar(alienSpeed * (deltaTime / 1000)));
                alien.lookAt(shipGroup.position);

                const now = Date.now();
                if (now > alien.lastFireTime + fireCooldown) {
                    alien.lastFireTime = now;
                    const laserMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                    const laserGeo = new THREE.CylinderGeometry(0.5, 0.5, 5, 8);
                    const laser = new THREE.Mesh(laserGeo, laserMat);
                    laser.position.copy(alien.position);
                    laser.velocity = new THREE.Vector3().subVectors(shipGroup.position, alien.position).normalize().multiplyScalar(50);
                    alienLasers.push(laser);
                    scene.add(laser);
                }
            }
        }

        function updateAlienLasers() {
             for (let i = alienLasers.length - 1; i >= 0; i--) {
                const laser = alienLasers[i];
                laser.position.add(laser.velocity);
                if (laser.position.distanceTo(shipGroup.position) > 4000) {
                    scene.remove(laser);
                    alienLasers.splice(i, 1);
                }
            }
        }
        
        function updateAlienLasers() {
             for (let i = alienLasers.length - 1; i >= 0; i--) {
                const laser = alienLasers[i];
                laser.position.add(laser.velocity);
                if (shipGroup && laser.position.distanceTo(shipGroup.position) > 4000) {
                    scene.remove(laser);
                    alienLasers.splice(i, 1);
                }
            }
        }

        // --- AKSI & KOLISI ---
        function handleAccessoryKeyPress(key) {
            if (isGameOver || isPaused) return;
            const now = Date.now();
            if (key === '1' && playerData.accessories.shield.level > 0 && now > accessoryCooldowns.shield) {
                const level = playerData.accessories.shield.level;
                shieldActive = true;
                accessoryCooldowns.shield = now + (60 - level) * 1000;
                setTimeout(() => shieldActive = false, (14 + level) * 1000);
            } else if (key === '2' && playerData.accessories.speed.level > 0 && now > accessoryCooldowns.speed) {
                 const level = playerData.accessories.speed.level;
                speedBoostActive = true;
                accessoryCooldowns.speed = now + (50 - level) * 1000;
                setTimeout(() => speedBoostActive = false, (11 + level) * 1000);
            } else if (key === '3' && playerData.accessories.warmth.level > 0 && now > accessoryCooldowns.warmth) {
                 const level = playerData.accessories.warmth.level;
                warmthActive = true;
                isFrozen = false;
                document.getElementById('freeze-warning').style.display = 'none';
                document.getElementById('warmth-container').style.display = 'block';
                maxWarmth = (60 + level * 5) * 1000;
                warmthDuration = maxWarmth;
                timeUntilFreeze = freezeTimer * DIFFICULTY_SETTINGS[currentLevel].freezeResist;
                accessoryCooldowns.warmth = now + (120 - level * 2) * 1000;
            }
        }
        function takeDamage(amount) {
            if (isGameOver || shieldActive) return;
            currentHealth -= amount;
            if (currentHealth <= 0) {
                currentHealth = 0;
                isGameOver = true;
                document.getElementById('game-over-reason').innerText = 'Pesawat Anda hancur!';
                document.getElementById('game-over-screen').style.display = 'flex';
            }
        }
        function checkCollisions() {
             if (alienBoss && shipGroup.position.distanceTo(alienBoss.position) < 25 + 4) {
                takeDamage(50); // Kerusakan tabrakan tinggi
                if (isGameOver) return;
            }
             for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                 if (shipGroup.position.distanceTo(asteroid.position) < (asteroid.scale.x || 30) + 4) { // Radius tabrakan pesawat disesuaikan
                    takeDamage(20); // Kerusakan akibat tabrakan
                    damageAsteroid(asteroid, 1000); // collision instantly destroys it
                    if (isGameOver) return;
                }
            }
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                if (!laser) continue;
                let laserRemoved = false;
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const asteroid = asteroids[j];
                    if (laser.position.distanceTo(asteroid.position) < (asteroid.scale.x || 30)) {
                        damageAsteroid(asteroid, 5);
                        if (!laser.isPiercing) { scene.remove(laser); lasers.splice(i, 1); laserRemoved = true; break; }
                    }
                }
                if (laserRemoved) continue;
                 for (let k = aliens.length - 1; k >= 0; k--) {
                    const alien = aliens[k];
                    if (laser.position.distanceTo(alien.position) < 10) {
                        alien.health -= 5;
                         if (alien.health <= 0) {
                            scene.remove(alien); aliens.splice(k, 1);
                            const pointMultiplier = 1 + (playerData.accessories.pointBooster.level * 0.4);
                            playerData.points += Math.round(50 * pointMultiplier); savePlayerData();
                        }
                        if (!laser.isPiercing) { scene.remove(laser); lasers.splice(i, 1); break; }
                    }
                }
                if (laserRemoved) continue;
                if (alienBoss) {
                    if (laser.position.distanceTo(alienBoss.position) < 25) { // Hitbox bos lebih besar
                        alienBoss.health -= 5;
                        if (alienBoss.health <= 0) {
                            const pointMultiplier = 1 + (playerData.accessories.pointBooster.level * 0.4);
                            playerData.points += Math.round(5000 * pointMultiplier); // Hadiah poin besar
                            savePlayerData();
                            scene.remove(alienBoss);
                            alienBoss = null;
                        }
                        if (!laser.isPiercing) { 
                            scene.remove(laser); lasers.splice(i, 1); laserRemoved = true; break; 
                        }
                    }
                }
            }
            for(let i = alienLasers.length - 1; i >= 0; i--) {
                const laser = alienLasers[i];
                if (shipGroup && laser.position.distanceTo(shipGroup.position) < 4) { // Radius tabrakan pesawat disesuaikan
                    takeDamage(9); // Kerusakan dari laser alien
                    scene.remove(laser);
                    alienLasers.splice(i, 1);
                }
            }
            for(let i = bossLasers.length - 1; i >= 0; i--) {
                const laser = bossLasers[i];
                if (shipGroup && laser.position.distanceTo(shipGroup.position) < 5) {
                    takeDamage(29); // Kerusakan laser bos
                    scene.remove(laser);
                    bossLasers.splice(i, 1);
                }
            }
        }
        function updateDistanceInfo() {
            if (!shipGroup || !target || isGameOver) return;
            const distance = shipGroup.position.distanceTo(target.object.position);
            document.getElementById('distance-info').innerText = `Jarak ke Target: ${Math.round(distance).toLocaleString()} m`;

            if (distance < 450) {
                const pointMultiplier = 1 + (playerData.accessories.pointBooster.level * 0.4);
                const pointsWon = Math.round(MISSIONS[currentMissionIndex].distance * DIFFICULTY_SETTINGS[currentLevel].pointMultiplier * pointMultiplier);
                playerData.points += pointsWon;
                savePlayerData();

                if (currentMissionIndex >= MISSIONS.length - 1) {
                    isGameOver = true; isPaused = true;
                    document.getElementById('win-screen').style.display = 'flex';
                    document.getElementById('win-message').innerText = `SELAMAT! Anda telah menjelajahi seluruh alam semesta! Bonus Akhir: ${pointsWon.toLocaleString()} poin.`;
                } else {
                    currentMissionIndex++;
                    scene.remove(target.object);
                    const nextMission = MISSIONS[currentMissionIndex];
                    document.getElementById('mission-title').innerText = nextMission.name;
                    let targetMaterial;
                    const isRealistic = playerData.settings && playerData.settings.realisticMode;
                    if (isRealistic) {
                        const textureUrl = PLANET_TEXTURES[currentMissionIndex % PLANET_TEXTURES.length];
                        const texture = textureLoader.load(textureUrl);
                        targetMaterial = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9 });
                    } else {
                        targetMaterial = new THREE.MeshPhongMaterial({ color: 0xE8A763 });
                    }
                    target = { object: new THREE.Mesh(new THREE.SphereGeometry(400, 64, 64), targetMaterial) };
                    target.object.position.z = -nextMission.distance;
                    scene.add(target.object);
                    const settings = DIFFICULTY_SETTINGS[currentLevel];
                    const currentZ = shipGroup.position.z;
                    createAsteroids(settings.asteroidCount, 0.5, -nextMission.distance, currentZ);
                    alert(`Misi Baru: ${nextMission.name}\n${nextMission.desc}\nPoin Bonus: ${pointsWon.toLocaleString()}`);
                    timeUntilFreeze = freezeTimer * settings.freezeResist;
                }
            }
        }
        // --- UPDATE LOOP ---
        let lastTime = 0;
        function animate(currentTime) {
            if (isGameOver) return;
            requestAnimationFrame(animate);
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            if (isGameStarted && !isPaused) {
                updateShipMovement(deltaTime);
                updateLasers();
                updateAliens(deltaTime);
                updateAlienLasers();
                updateAlienBoss(deltaTime);
                updateBossLasers();
                updateUIBars();
                checkCollisions();
                updateScenery();
                updateFreezeStatus(deltaTime);
                updateMinimap();
                updateSwordSensor();
                updateFriends();
                updateDistanceInfo();

                if (cameraMode !== 2) { // Mode Belakang dan Depan
                    let relativeCameraOffset;
                    if (cameraMode === 0) { // Mode Belakang
                        relativeCameraOffset = new THREE.Vector3(0, 5, -20 - (speed / 2));
                    } else { // Mode Depan
                        relativeCameraOffset = new THREE.Vector3(0, 4, 25);
                    }
                    const cameraOffset = relativeCameraOffset.applyMatrix4(shipGroup.matrixWorld);
                    camera.position.lerp(cameraOffset, 0.1);
                    camera.lookAt(shipGroup.position);
                }
                // Untuk mode 2 (kokpit), tidak ada logic di sini karena kamera sudah menjadi child dari shipGroup.
            }
            renderer.render(scene, camera);
        }
        function updateUIBars() {
            document.getElementById('fuel-bar').style.width = `${(currentFuel / maxFuel) * 100}%`;
            document.getElementById('health-bar').style.width = `${(currentHealth / maxHealth) * 100}%`;
            const statusDiv = document.getElementById('accessory-status');
            statusDiv.innerHTML = `
                ${shieldActive ? '<p style="color:var(--primary-color)">SHIELD AKTIF</p>' : ''}
                ${speedBoostActive ? '<p style="color:yellow">SPEED BOOST AKTIF</p>' : ''}
                ${warmthActive ? '<p style="color:orange">PEMANAS AKTIF</p>' : ''}
            `;
        }
        function updateLasers() {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                laser.position.add(laser.velocity);
                if (laser.position.distanceTo(shipGroup.position) > 3000) {
                    scene.remove(laser);
                    lasers.splice(i, 1);
                }
            }
        }
        function updateScenery() {
            starField.rotation.y += 0.00002;
            asteroids.forEach(a => { 
                a.position.add(a.velocity); 
                if (a.rotationSpeed) {
                    a.rotation.x += a.rotationSpeed.x;
                    a.rotation.y += a.rotationSpeed.y;
                    a.rotation.z += a.rotationSpeed.z;
                } else {
                    a.rotation.x += 0.005; a.rotation.y += 0.005; 
                }
            });
        }
        function updateMinimap() {
            if (!minimapCtx || !shipGroup) return;

            const mapSize = 200;
            const mapCenter = mapSize / 2;

            minimapCtx.clearRect(0, 0, mapSize, mapSize);

            // Gambar pemain
            minimapCtx.fillStyle = 'cyan';
            minimapCtx.beginPath();
            minimapCtx.moveTo(mapCenter, mapCenter - 5);
            minimapCtx.lineTo(mapCenter - 4, mapCenter + 4);
            minimapCtx.lineTo(mapCenter + 4, mapCenter + 4);
            minimapCtx.closePath();
            minimapCtx.fill();

            // Gambar asteroid
            minimapCtx.fillStyle = '#8B4513'; // Coklat
            asteroids.forEach(asteroid => {
                const dx = (asteroid.position.x - shipGroup.position.x) / minimapScale;
                const dy = (asteroid.position.z - shipGroup.position.z) / minimapScale;
                const mapX = mapCenter + dx;
                const mapY = mapCenter + dy;
                if (Math.abs(dx) < mapCenter && Math.abs(dy) < mapCenter) {
                    minimapCtx.fillRect(mapX - 1, mapY - 1, 2, 2);
                }
            });

            // Gambar alien
            minimapCtx.fillStyle = '#9400D3'; // Ungu
            aliens.forEach(alien => {
                const dx = (alien.position.x - shipGroup.position.x) / minimapScale;
                const dy = (alien.position.z - shipGroup.position.z) / minimapScale;
                const mapX = mapCenter + dx;
                const mapY = mapCenter + dy;
                if (Math.abs(dx) < mapCenter && Math.abs(dy) < mapCenter) {
                    minimapCtx.beginPath(); minimapCtx.arc(mapX, mapY, 2, 0, Math.PI * 2); minimapCtx.fill();
                }
            });

            // Gambar Bos Alien
            if (alienBoss) {
                minimapCtx.fillStyle = 'red';
                const dx = (alienBoss.position.x - shipGroup.position.x) / minimapScale; const dy = (alienBoss.position.z - shipGroup.position.z) / minimapScale; const mapX = mapCenter + dx; const mapY = mapCenter + dy;
                if (Math.abs(dx) < mapCenter && Math.abs(dy) < mapCenter) {
                    minimapCtx.beginPath(); minimapCtx.arc(mapX, mapY, 5, 0, Math.PI * 2); minimapCtx.fill();
                }
            }

            // Gambar teman
            minimapCtx.fillStyle = '#00ffff'; // Cyan terang
            friends.forEach(friend => {
                const dx = (friend.shipGroup.position.x - shipGroup.position.x) / minimapScale;
                const dy = (friend.shipGroup.position.z - shipGroup.position.z) / minimapScale;
                const mapX = mapCenter + dx;
                const mapY = mapCenter + dy;
                if (Math.abs(dx) < mapCenter && Math.abs(dy) < mapCenter) {
                    minimapCtx.fillRect(mapX - 1, mapY - 1, 3, 3); // Kotak yang sedikit lebih besar
                }
            });
        }
        function fireProjectile() {
            if (isFrozen || isPaused || isGameOver || !shipGroup) return;

            // Cooldown untuk mencegah spam
            const now = Date.now();
            const cooldown = currentProjectileStats.type === 'burst' ? 400 : 200;
            if (shipGroup.lastFireTime && now < shipGroup.lastFireTime + cooldown) {
                return;
            }
            shipGroup.lastFireTime = now;

            const createLaser = (spawnOffset, direction) => {
                const laser = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 2, 8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                const spawnPoint = spawnOffset.clone().applyMatrix4(shipGroup.matrixWorld);
                
                laser.position.copy(spawnPoint);
                
                // Arahkan laser ke arah kecepatan
                const targetPosition = laser.position.clone().add(direction);
                laser.lookAt(targetPosition);
                laser.rotateX(Math.PI / 2); // Koreksi orientasi untuk silinder

                laser.velocity = direction.clone().multiplyScalar(laserFireSpeed);
                
                if (currentProjectileStats.type === 'piercing' || currentProjectileStats.piercing) {
                    laser.isPiercing = true;
                }

                lasers.push(laser);
                scene.add(laser);
            };

            const baseDirection = new THREE.Vector3();
            shipGroup.getWorldDirection(baseDirection); // Arah depan adalah Z positif

            const projectileType = currentProjectileStats.type || 'standard';
            const spawnOrigin = new THREE.Vector3(0, 0, 2.5); // Titik spawn di depan pesawat

            switch (projectileType) {
                case 'double': {
                    const rightOffset = new THREE.Vector3(0.5, 0, 2.5);
                    const leftOffset = new THREE.Vector3(-0.5, 0, 2.5);
                    createLaser(rightOffset, baseDirection);
                    createLaser(leftOffset, baseDirection);
                    break;
                }
                case 'spread': {
                    const count = currentProjectileStats.count || 3;
                    const spreadAngle = 0.15; // radians
                    for (let i = 0; i < count; i++) {
                        const angle = (i - (count - 1) / 2) * spreadAngle;
                        const spreadDirection = baseDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                        createLaser(spawnOrigin, spreadDirection);
                    }
                    break;
                }
                case 'burst': {
                    const count = currentProjectileStats.count || 3;
                    const burstDelay = 80;
                    for (let i = 0; i < count; i++) {
                        setTimeout(() => {
                            if (!isGameOver && shipGroup) {
                                const currentDirection = new THREE.Vector3();
                                shipGroup.getWorldDirection(currentDirection);
                                createLaser(spawnOrigin, currentDirection);
                            }
                        }, i * burstDelay);
                    }
                    break;
                }
                case 'piercing':
                case 'standard':
                default: {
                    createLaser(spawnOrigin, baseDirection);
                    break;
                }
            }
        }
        // --- Helper functions ---
        function generateShipDatabase() {
            const baseShips = [
                {id: 0, name: 'Pioneer', cost: 0, desc: 'Tembakan standar. Pesawat seimbang untuk pemula.', projectile: { type: 'standard' }},
                {id: 1, name: 'Dart', cost: 100, desc: 'Tembakan standar. Lebih cepat dan lincah.', projectile: { type: 'standard' }},
                {id: 2, name: 'Bulwark', cost: 120, desc: 'Tembakan standar. Bahan bakar lebih awet.', projectile: { type: 'standard' }},
                {id: 3, name: 'Hornet', cost: 250, desc: 'Tembakan ganda (double shot).', projectile: { type: 'double' }},
                {id: 4, name: 'Endurance', cost: 300, desc: 'Tembakan standar. Kapasitas bahan bakar sangat besar.', projectile: { type: 'standard' }},
                {id: 5, name: 'Interceptor', cost: 800, desc: 'Tembakan ganda. Sangat cepat.', projectile: { type: 'double' }},
                {id: 6, name: 'Goliath', cost: 1000, desc: 'Tembakan menyebar (spread shot).', projectile: { type: 'spread', count: 3 }},
                {id: 7, name: 'Javelin', cost: 1500, desc: 'Tembakan penembus (railgun).', projectile: { type: 'piercing' }},
                {id: 8, name: 'Wasp', cost: 2000, desc: 'Tembakan beruntun 3x (burst fire).', projectile: { type: 'burst', count: 3 }},
                {id: 9, name: 'Aegis', cost: 2500, desc: 'Tembakan ganda. Seimbang.', projectile: { type: 'double' }},
                {id: 10, name: 'Comet', cost: 3500, desc: 'Tembakan beruntun 3x. Akselerasi instan.', projectile: { type: 'burst', count: 3 }},
                {id: 11, name: 'Nomad', cost: 5000, desc: 'Tembakan standar. Efisiensi bahan bakar tinggi.', projectile: { type: 'standard' }},
                {id: 12, name: 'Stingray', cost: 6000, desc: 'Tembakan penembus. Canggih.', projectile: { type: 'piercing' }},
                {id: 13, name: 'Wraith', cost: 10000, desc: 'Tembakan beruntun 3x. Siluman cepat.', projectile: { type: 'burst', count: 3 }},
                {id: 14, name: 'Leviathan', cost: 12000, desc: 'Tembakan menyebar 3x. Bahan bakar masif.', projectile: { type: 'spread', count: 3 }},
                {id: 15, name: 'Nova', cost: 15000, desc: 'Tembakan ganda cepat. Akselerasi gila.', projectile: { type: 'double' }},
                {id: 16, name: 'Phantom', cost: 18000, desc: 'Tembakan menyebar 3x. Manuverabilitas tak tertandingi.', projectile: { type: 'spread', count: 3 }},
                {id: 17, name: 'Valkyrie', cost: 22000, desc: 'Tembakan beruntun 5x.', projectile: { type: 'burst', count: 5 }},
                {id: 18, name: 'Trident', cost: 28000, desc: 'Tembakan menyebar 3x lebar.', projectile: { type: 'spread', count: 3 }},
                {id: 19, name: 'Odyssey', cost: 35000, desc: 'Tembakan standar kuat. Untuk misi terpanjang.', projectile: { type: 'standard' }},
                {id: 20, name: 'Tempest', cost: 45000, desc: 'Tembakan penembus cepat.', projectile: { type: 'piercing' }},
                {id: 21, name: 'Wyvern', cost: 60000, desc: 'Tembakan menyebar 5x.', projectile: { type: 'spread', count: 5 }},
                {id: 22, name: 'Colossus', cost: 75000, desc: 'Tembakan ganda super.', projectile: { type: 'double' }},
                {id: 23, name: 'Helios', cost: 90000, desc: 'Tembakan penembus super.', projectile: { type: 'piercing' }},
                {id: 24, name: 'Spectre', cost: 110000, desc: 'Tembakan beruntun 5x cepat.', projectile: { type: 'burst', count: 5 }},
                {id: 25, name: 'Paladin', cost: 140000, desc: 'Tembakan menyebar 5x. Superior.', projectile: { type: 'spread', count: 5 }},
                {id: 26, name: 'Archon', cost: 180000, desc: 'Tembakan penembus kilat.', projectile: { type: 'piercing' }},
                {id: 27, name: 'Star-Eater', cost: 250000, desc: 'Tembakan menyebar 5x masif.', projectile: { type: 'spread', count: 5 }},
                {id: 28, name: 'Hypersonic', cost: 320000, desc: 'Tembakan beruntun 7x.', projectile: { type: 'burst', count: 7 }},
                {id: 29, name: 'Zenith', cost: 500000, desc: 'Tembakan menyebar 7x. Sempurna.', projectile: { type: 'spread', count: 7 }},
                {id: 30, name: 'Celestial', cost: 750000, desc: 'Tembakan penembus pamungkas.', projectile: { type: 'piercing' }},
                {id: 31, name: 'Cosmic Singularity', cost: 1000000, desc: 'Menembakkan badai proyektil.', projectile: { type: 'spread', count: 9 }},
                {id: 32, name: 'Nebula', cost: 1250000, desc: 'Tembakan menyebar plasma.', projectile: { type: 'spread', count: 5 }},
                {id: 33, name: 'Quasar', cost: 1500000, desc: 'Semburan energi terfokus.', projectile: { type: 'piercing' }},
                {id: 34, name: 'Pulsar', cost: 1800000, desc: 'Tembakan beruntun energi denyut.', projectile: { type: 'burst', count: 5 }},
                {id: 35, name: 'Supernova', cost: 2200000, desc: 'Ledakan proyektil area luas.', projectile: { type: 'spread', count: 9 }},
                {id: 36, name: 'Voidreaver', cost: 2700000, desc: 'Tembakan penembus dimensi.', projectile: { type: 'piercing' }},
                {id: 37, name: 'Seraphim', cost: 3300000, desc: 'Menembakkan rentetan misil suci.', projectile: { type: 'burst', count: 7 }},
                {id: 38, name: 'Behemoth', cost: 4000000, desc: 'Kuat namun lambat, tembakan meriam plasma ganda.', projectile: { type: 'double' }},
                {id: 39, name: 'Chimera', cost: 4800000, desc: 'Menggabungkan tembakan menyebar dan beruntun.', projectile: { type: 'spread', count: 3 }},
                {id: 40, name: 'Dragonfyre', cost: 5700000, desc: 'Menyemburkan api kosmik terus-menerus.', projectile: { type: 'standard' }},
                {id: 41, name: 'Eclipse', cost: 6800000, desc: 'Menembakkan proyektil kegelapan yang melacak musuh.', projectile: { type: 'standard' }},
                {id: 42, name: 'Galeforce', cost: 8000000, desc: 'Tembakan beruntun super cepat, mengoyak lawan.', projectile: { type: 'burst', count: 9 }},
                {id: 43, name: 'Aetherwing', cost: 10000000, desc: 'Tembakan menyebar 9x yang menembus.', projectile: { type: 'spread', count: 9, piercing: true }},
                {id: 44, name: 'Chronomancer', cost: 12500000, desc: 'Proyektil yang dapat memanipulasi waktu.', projectile: { type: 'standard' }},
                {id: 45, name: 'Dreadnought', cost: 15000000, desc: 'Benteng terbang dengan persenjataan berat.', projectile: { type: 'double' }},
                {id: 46, name: 'Excalibur', cost: 18000000, desc: 'Menembakkan satu bilah energi yang sangat kuat.', projectile: { type: 'piercing' }},
                {id: 47, name: 'Fenrir', cost: 22000000, desc: 'Sangat lincah dengan tembakan beruntun yang ganas.', projectile: { type: 'burst', count: 5 }},
                {id: 48, name: 'Genesis', cost: 27000000, desc: 'Menciptakan ledakan kecil di setiap tembakan.', projectile: { type: 'standard' }},
                {id: 49, name: 'Hyperion', cost: 33000000, desc: 'Meriam surya yang membutuhkan waktu untuk mengisi daya.', projectile: { type: 'piercing' }},
                {id: 50, name: 'Icarus', cost: 40000000, desc: 'Terlalu cepat, menembakkan laser dari sayapnya.', projectile: { type: 'double' }},
                {id: 51, name: 'Juggernaut', cost: 50000000, desc: 'Tidak bisa dihentikan, menembus semua rintangan.', projectile: { type: 'piercing' }},
                {id: 52, name: 'Karma', cost: 75000000, desc: 'Setiap tembakan yang kena akan kembali lebih kuat.', projectile: { type: 'standard' }},
            ];
            baseShips.forEach((ship, index) => {
                const projectile = ship.projectile || { type: 'standard' };
                SPACESHIPS.push({ ...ship, stats: { health: 100 + (index * 30), maxSpeed: 18 + (index * 0.9), fuel: 250 + (index * 25), accel: 0.18 + (index * 0.009), turn: 0.035 + (index * 0.0006), laserSpeed: 60 + (index * 3.5), refuelRate: 2 + (index * 0.1), projectile: projectile }});
            });
        }
        async function checkPing() {
            // Fitur ini mengukur waktu respons dari server tempat game di-host.
            // Ini akan berfungsi dengan baik saat file diunggah ke server web,
            // tetapi akan menunjukkan latensi ~0ms atau error jika dijalankan secara lokal dari file.
            const startTime = Date.now();
            try {
                // Menggunakan HEAD request ke resource yang sama untuk efisiensi, dengan cache-busting
                await fetch(window.location.href.split('?')[0] + '?ping=' + Date.now(), { method: 'HEAD', cache: 'no-store' });
                const latency = Date.now() - startTime;
                
                pingValue.textContent = `${latency} ms`;
                networkIndicator.className = 'network-status-indicator'; // Reset kelas

                if (latency <= 79) {
                    networkIndicator.classList.add('good');
                } else if (latency <= 97) {
                    networkIndicator.classList.add('medium');
                } else { // > 97ms
                    networkIndicator.classList.add('bad');
                }
            } catch (e) {
                pingValue.textContent = 'N/A';
                networkIndicator.className = 'network-status-indicator';
                networkIndicator.classList.add('bad');
            }
        }
        function setupJoystick() { /* Logika joystick dari kode lama */ }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }, false);
        init();
    </script>
</body>
</html>
